"""
MABE Realization Engine — Sprint R3 Bootstrap (Registry + Ranker + Lignin Adapter)
Run from your MABE repo root: python realization/bootstrap_r3.py

Requires: Sprint R1 + R2a + R2b + R2c already installed
Creates/overwrites: 6 files (4 new + 2 updated)
Test:     python -m pytest mabe/realization/tests/test_sprint_r3.py -v
"""

import os
import sys

if not os.path.isfile("mabe/realization/__init__.py"):
    print("ERROR: Sprint R1 not found. Run bootstrap_realization.py first.")
    sys.exit(1)


def write_file(path, content):
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", encoding="utf-8", newline="\n") as f:
        f.write(content)


FILES = {
    'mabe/realization/models.py': '"""\nData models for the MABE Realization Engine.\n\nThese are physics objects. They do not know what a protein is.\n\nHierarchy:\n    InteractionGeometrySpec  (Layer 2 output, our input)\n    → IdealPocketSpec        (Phase 1 output: the physics optimum)\n    → DeviationReport        (per-material deviation from ideal)\n    → RealizationScore       (per-material composite score)\n    → RankedRealizations     (sorted output with gap analysis)\n    → FabricationSpec        (Layer 4 output: buildable design)\n"""\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Optional\n\n\n# ─────────────────────────────────────────────\n# Enums\n# ─────────────────────────────────────────────\n\nclass CavityShape(str, Enum):\n    """Pocket geometry classification."""\n    SPHERE = "sphere"\n    CONE = "cone"\n    CHANNEL = "channel"\n    CLEFT = "cleft"\n    FLAT = "flat"\n    BARREL = "barrel"\n    CUSTOM = "custom"\n\n\nclass RigidityClass(str, Enum):\n    """\n    Derived from tightest precision requirement in the ideal pocket.\n    <0.05 Å → crystalline, <0.2 → preorganized, <0.5 → semi-flexible, else → any.\n    """\n    CRYSTALLINE = "crystalline"\n    PREORGANIZED = "preorganized"\n    SEMI_FLEXIBLE = "semi-flexible"\n    ANY = "any"\n\n\nclass Solvent(str, Enum):\n    AQUEOUS = "aqueous"\n    ORGANIC = "organic"\n    MIXED = "mixed"\n    GAS = "gas"\n\n\nclass ApplicationContext(str, Enum):\n    DIAGNOSTIC = "diagnostic"\n    REMEDIATION = "remediation"\n    THERAPEUTIC = "therapeutic"\n    RESEARCH = "research"\n    SEPARATION = "separation"\n    CATALYSIS = "catalysis"\n\n\nclass ScaleClass(str, Enum):\n    NMOL = "nmol"\n    UMOL = "µmol"\n    MMOL = "mmol"\n    MOL = "mol"\n    KMOL = "kmol"\n\n    @property\n    def rank(self) -> int:\n        return list(ScaleClass).index(self)\n\n\n# ─────────────────────────────────────────────\n# Sub-components\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass DonorPosition:\n    """A single interaction element in the geometry spec."""\n    atom_type: str                    # "N", "O", "S", "Se", etc.\n    coordination_role: str            # "axial", "equatorial", "bridging", "terminal"\n    position_vector_A: tuple[float, float, float]  # relative to cavity center\n    tolerance_A: float                # how precisely this must be placed\n    required_hybridization: str       # "sp2", "sp3", "any"\n    charge_state: float = 0.0        # partial charge requirement\n\n\n@dataclass(frozen=True)\nclass ExclusionSpec:\n    """A species that must NOT bind."""\n    species: str\n    max_allowed_affinity_kJ_mol: float\n    exclusion_mechanism: str          # "size", "charge", "geometry", "kinetic"\n\n\n@dataclass(frozen=True)\nclass CavityDimensions:\n    """Physical dimensions of the pocket cavity."""\n    volume_A3: float\n    aperture_A: float                 # narrowest opening\n    depth_A: float\n    max_internal_diameter_A: float\n    aspect_ratio: float = 1.0        # depth / width\n\n\n@dataclass(frozen=True)\nclass HydrophobicSurface:\n    """A non-polar contact region in the pocket."""\n    center_A: tuple[float, float, float]\n    area_A2: float\n    normal_vector: tuple[float, float, float]\n\n\n@dataclass(frozen=True)\nclass HBondSpec:\n    """Hydrogen bond network requirement."""\n    donors: list[tuple[float, float, float]]   # positions of H-bond donors\n    acceptors: list[tuple[float, float, float]] # positions of H-bond acceptors\n    required_geometry: str = "any"              # "linear", "bifurcated", "any"\n\n\n# ─────────────────────────────────────────────\n# Layer 2 Output / Layer 3 Input\n# ─────────────────────────────────────────────\n\n@dataclass\nclass InteractionGeometrySpec:\n    """\n    Realization-agnostic pocket description. Layer 2 output.\n\n    This is a physics object. It describes a field of interaction\n    potentials in 3D space. It does not know what a protein is.\n    """\n\n    # ── Cavity geometry ──\n    cavity_shape: CavityShape\n    cavity_dimensions: CavityDimensions\n    symmetry: str = "none"           # "C3v", "D4h", "none", etc.\n\n    # ── Interaction elements ──\n    donor_positions: list[DonorPosition] = field(default_factory=list)\n    hydrophobic_surfaces: list[HydrophobicSurface] = field(default_factory=list)\n    h_bond_network: Optional[HBondSpec] = None\n\n    # ── Flexibility constraints ──\n    rigidity_requirement: str = "semi-rigid"\n    max_backbone_rmsd_A: float = 1.0\n    conformational_penalty_budget_kJ_mol: float = 10.0\n\n    # ── Scale ──\n    pocket_scale_nm: float = 0.5\n    multivalency: int = 1\n\n    # ── Selectivity constraints ──\n    must_exclude: list[ExclusionSpec] = field(default_factory=list)\n\n    # ── Operating conditions ──\n    pH_range: tuple[float, float] = (5.0, 9.0)\n    temperature_range_K: tuple[float, float] = (273.15, 373.15)\n    solvent: Solvent = Solvent.AQUEOUS\n    ionic_strength_M: float = 0.1\n\n    # ── Application context (informs realization, doesn\'t constrain geometry) ──\n    target_application: ApplicationContext = ApplicationContext.RESEARCH\n    required_scale: ScaleClass = ScaleClass.UMOL\n    cost_ceiling_per_unit: Optional[float] = None\n    reusability_required: bool = False\n\n    @property\n    def required_donor_types(self) -> set[str]:\n        return {d.atom_type for d in self.donor_positions}\n\n    @property\n    def tightest_tolerance_A(self) -> float:\n        if not self.donor_positions:\n            return float("inf")\n        return min(d.tolerance_A for d in self.donor_positions)\n\n\n# ─────────────────────────────────────────────\n# Layer 3 Phase 1 Output: The Ideal Pocket\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass IdealElement:\n    """One interaction element in the physics-optimal pocket."""\n    atom_type: str\n    exact_position_A: tuple[float, float, float]\n    required_precision_A: float\n    orbital_hybridization: str\n    charge_state: float\n    interaction_energy_contribution_kJ_mol: float\n\n\n@dataclass\nclass IdealPocketSpec:\n    """\n    The physics-optimal pocket. No material constraints. Pure geometry + thermodynamics.\n\n    This is the reference standard. Every material system is scored by\n    deviation from this object.\n    """\n\n    # ── Computed from InteractionGeometrySpec ──\n    optimal_elements: list[IdealElement]\n\n    # ── Derived pocket properties ──\n    ideal_cavity_volume_A3: float\n    ideal_cavity_shape: CavityShape\n    ideal_desolvation_energy_kJ_mol: float\n    ideal_binding_energy_kJ_mol: float\n\n    # ── Fabrication requirements (material-agnostic) ──\n    min_precision_required_A: float\n    rigidity_class: RigidityClass\n    min_stability_pH: tuple[float, float]\n    min_stability_K: tuple[float, float]\n    required_elements: set[str]\n    symmetry_exploitable: bool\n\n    # ── The ideal material spec (when nothing scores high enough) ──\n    ideal_material_requirements: str = ""\n    critical_constraints: list[str] = field(default_factory=list)\n\n\n# ─────────────────────────────────────────────\n# Layer 3 Phase 2: Deviation + Scoring\n# ─────────────────────────────────────────────\n\n@dataclass\nclass DeviationReport:\n    """How a specific material system deviates from the IdealPocketSpec."""\n    material_system: str\n    element_deviations_A: list[float]\n    max_deviation_A: float\n    mean_deviation_A: float\n    rigidity_deviation: float = 0.0          # 0 = exact match, 1 = completely wrong\n    electrostatic_field_correlation: float = 1.0  # 0–1\n    missing_interactions: list[str] = field(default_factory=list)\n    compensating_interactions: list[str] = field(default_factory=list)\n\n\n@dataclass\nclass RealizationScore:\n    """Score for one material system against the IdealPocketSpec."""\n\n    material_system: str\n    adapter_id: str\n\n    # ── Physics deviation (PRIMARY) ──\n    deviation_from_ideal: DeviationReport\n    physics_fidelity: float               # 0.0–1.0, derived from deviation\n\n    # ── Implementation axes (SECONDARY — precision binders) ──\n    synthetic_accessibility: float = 0.0\n    cost_score: float = 0.0\n    scalability: float = 0.0\n    operating_condition_compatibility: float = 0.0\n    reusability_score: float = 0.0\n\n    # ── Bulk sorbent axes (populated by Class D adapters) ──\n    capacity_mmol_per_g: float = 0.0       # qmax from isotherm\n    selectivity_factor: float = 0.0        # α = Kd_target / Kd_competitor\n    throughput_L_per_h_per_kg: float = 0.0 # column flow at breakthrough\n    regenerability_cycles: int = 0         # sorption/desorption cycles\n    cost_per_kg_processed: float = 0.0     # $/kg of target removed\n\n    # ── Physics class tag ──\n    physics_class: str = ""                # "covalent_cavity", "bulk_sorbent", etc.\n\n    # ── Composite ──\n    composite_score: float = 0.0\n    confidence: float = 0.0               # calibrated from literature success rates\n\n    # ── Rationale ──\n    advantages: list[str] = field(default_factory=list)\n    limitations: list[str] = field(default_factory=list)\n    critical_risk: Optional[str] = None\n\n    # ── Feasibility gate ──\n    feasible: bool = True\n    infeasibility_reason: Optional[str] = None\n\n\n@dataclass\nclass RankedRealizations:\n    """Layer 3 complete output."""\n\n    # ── The physics target ──\n    geometry_spec: InteractionGeometrySpec\n    ideal_pocket: IdealPocketSpec\n\n    # ── Material rankings ──\n    rankings: list[RealizationScore]\n    recommended: str\n    recommendation_rationale: str = ""\n\n    # ── Gap analysis ──\n    best_physics_fidelity: float = 0.0\n    gap_to_ideal: float = 1.0\n    gap_report: Optional[str] = None\n    novel_material_suggestion: Optional[str] = None\n\n\n# ─────────────────────────────────────────────\n# Layer 4 Output: Fabrication Spec\n# ─────────────────────────────────────────────\n\n@dataclass\nclass FabricationSpec:\n    """\n    Base class for all Layer 4 adapter outputs.\n    Each adapter subclasses with material-specific fields.\n    """\n\n    material_system: str\n    geometry_spec_hash: str               # traceability to input\n    predicted_pocket_geometry: CavityDimensions\n    predicted_deviation_from_ideal_A: float\n\n    # ── Synthesis / fabrication ──\n    synthesis_steps: list[str] = field(default_factory=list)\n    estimated_yield: float = 0.0\n    estimated_cost_per_unit: float = 0.0\n    estimated_time: str = ""\n\n    # ── Characterization plan ──\n    validation_experiments: list[str] = field(default_factory=list)\n    expected_observables: dict = field(default_factory=dict)\n\n    # ── Files ──\n    structure_file: Optional[str] = None  # PDB, CIF, MOL, oxDNA, etc.\n    order_sheet: Optional[str] = None\n    protocol: Optional[str] = None\n',
    'mabe/realization/adapters/crown_ether_adapter.py': '"""\nCrown Ether / Cryptand Adapter — Layer 4 Implementation.\n\nTakes an InteractionGeometrySpec describing a cation-coordination pocket\nand designs a crown ether or cryptand realization.\n\nDesign logic:\n    1. Identify target cation from spec (donor types + charge + cavity size)\n    2. Rank crown ethers and cryptands by cavity size-match\n    3. HSAB routing for donor atom selection (O/N/S variants)\n    4. Cryptand upgrade when 3D encapsulation improves selectivity\n    5. Produce CrownEtherFabSpec with selection + Izatt-sourced logK\n\nPhysics connection:\n    - Cavity radius → size-match Gaussian (Hancock & Martell)\n    - Macrocyclic stabilization (Haymore et al.)\n    - Cryptate effect (Lehn)\n    - HSAB donor selection (from BackSolve donor subtype calibration)\n"""\n\nfrom __future__ import annotations\n\nimport hashlib\nimport math\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mabe.realization.adapters.base import RealizationAdapter, ValidationReport\nfrom mabe.realization.adapters.crown_ether_knowledge import (\n    ALL_HOSTS_LIST,\n    CATION_DB,\n    CationTarget,\n    CrownEtherHost,\n    CRYPTANDS,\n    hsab_donor_score,\n    select_best_crown,\n    size_match_dG,\n    size_match_score,\n    SIZE_MATCH_SIGMA_A,\n)\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    CavityShape,\n    DeviationReport,\n    FabricationSpec,\n    InteractionGeometrySpec,\n    RealizationScore,\n    Solvent,\n)\nfrom mabe.realization.registry.material_registry import MaterialCapability\n\n\n# ─────────────────────────────────────────────\n# CrownEtherFabSpec — material-specific output\n# ─────────────────────────────────────────────\n\n@dataclass\nclass CrownEtherFabSpec(FabricationSpec):\n    """Fabrication spec for a crown ether or cryptand pocket."""\n\n    # ── Selection ──\n    selected_host: str = ""\n    host_class: str = ""                   # "crown_ether", "aza_crown", etc.\n    cavity_radius_A: float = 0.0\n\n    # ── Target cation ──\n    target_ion: str = ""\n    ion_radius_A: float = 0.0\n\n    # ── Size-match analysis ──\n    size_match_score: float = 0.0\n    size_match_quality: str = ""\n\n    # ── Binding prediction ──\n    predicted_logK: float = 0.0\n    logK_source: str = ""                  # "Izatt_measured" or "estimated"\n    macrocyclic_stabilization_kJ_mol: float = 0.0\n    cryptate_stabilization_kJ_mol: float = 0.0\n    predicted_selectivity_ratio: float = 0.0  # vs best competitor\n\n    # ── HSAB analysis ──\n    hsab_compatibility: float = 0.0\n    donor_types_used: list[str] = field(default_factory=list)\n\n    # ── Design decisions ──\n    cryptand_upgrade: bool = False\n    cryptand_upgrade_rationale: str = ""\n    donor_substitution: str = ""           # "none", "aza", "thia"\n    donor_substitution_rationale: str = ""\n\n    # ── Sourcing ──\n    smiles: str = ""\n    supplier: str = ""\n    catalog_note: str = ""\n\n\n# ─────────────────────────────────────────────\n# Adapter implementation\n# ─────────────────────────────────────────────\n\nclass CrownEtherAdapter(RealizationAdapter):\n    """\n    Designs crown ether / cryptand binding pockets for cation capture.\n\n    Class A (Covalent Cavity) system:\n        - 0.60–1.70 Å cavity radius (12C4 through 21C7)\n        - Circular/spherical coordination geometry\n        - Size-match selectivity is primary mechanism\n        - O-donors default, N/S for borderline/soft cations\n        - Cryptands add 3D encapsulation (+5–20 kJ/mol)\n    """\n\n    def __init__(self, capability: Optional[MaterialCapability] = None):\n        if capability is None:\n            from mabe.realization.registry.material_registry import MATERIAL_REGISTRY\n            capability = MATERIAL_REGISTRY.get("cyclic_encapsulant")\n            if capability is None:\n                capability = _make_crown_capability()\n        super().__init__(capability)\n\n    def estimate_fidelity(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> RealizationScore:\n        """\n        Quick score: can a crown ether or cryptand host this geometry?\n\n        Primary: cavity size → size-match to target ion.\n        Secondary: donor type compatibility (HSAB).\n        """\n\n        target_ion, cation = self._identify_target_cation(spec)\n\n        if cation is None:\n            return self._infeasible_score(\n                "Cannot identify target cation from spec"\n            )\n\n        # ── Rank all hosts ──\n        ranked = select_best_crown(\n            target_ion,\n            require_water_soluble=(spec.solvent == Solvent.AQUEOUS),\n        )\n\n        if not ranked:\n            return self._infeasible_score(\n                f"No host compatible with {target_ion}"\n            )\n\n        best_host, combined_score, predicted_logK, rationale = ranked[0]\n\n        # ── Physics fidelity ──\n        sm = size_match_score(cation.ionic_radius_A, best_host.cavity_radius_A)\n        hsab = hsab_donor_score(cation.hsab_class, best_host.donor_types)\n\n        physics_fidelity = sm * 0.6 + hsab * 0.2\n\n        # Shape: crowns are circular, cryptands are spherical\n        if spec.cavity_shape == CavityShape.SPHERE and best_host.is_3d_cage:\n            physics_fidelity += 0.15\n        elif spec.cavity_shape in (CavityShape.FLAT, CavityShape.SPHERE):\n            physics_fidelity += 0.05\n\n        physics_fidelity = max(0.0, min(1.0, physics_fidelity))\n\n        # ── Deviation ──\n        radius_dev = abs(cation.ionic_radius_A - best_host.cavity_radius_A)\n        deviation = DeviationReport(\n            material_system="crown_ether",\n            element_deviations_A=[radius_dev],\n            max_deviation_A=radius_dev,\n            mean_deviation_A=radius_dev,\n        )\n\n        # ── Advantages / limitations ──\n        advantages = []\n        limitations = []\n\n        if best_host.commercial:\n            advantages.append(\n                f"{best_host.common_name} commercial "\n                f"(${best_host.cost_per_gram_usd}/g)"\n            )\n        if sm > 0.8:\n            advantages.append(f"Excellent size match (score={sm:.2f})")\n        if predicted_logK > 5:\n            advantages.append(f"Strong binding (logK={predicted_logK:.1f})")\n        if best_host.is_3d_cage:\n            advantages.append("Cryptate effect — enhanced selectivity")\n\n        if sm < 0.5:\n            limitations.append(f"Suboptimal size match ({sm:.2f})")\n        if not best_host.water_soluble and spec.solvent == Solvent.AQUEOUS:\n            limitations.append("Not water-soluble")\n        if hsab < 0.5:\n            limitations.append(\n                f"HSAB mismatch: {cation.hsab_class} ion, "\n                f"O-donors suboptimal"\n            )\n\n        # ── Selectivity from known logK ──\n        selectivity_factor = 1.0\n        if predicted_logK > 2:\n            # Rough: selectivity = 10^(logK_target - logK_nearest_competitor)\n            # Most crown ethers have ~2 logK unit selectivity over next ion\n            selectivity_factor = 10 ** min(predicted_logK * 0.3, 4.0)\n\n        return RealizationScore(\n            material_system="crown_ether",\n            adapter_id="CrownEtherAdapter",\n            deviation_from_ideal=deviation,\n            physics_fidelity=physics_fidelity,\n            synthetic_accessibility=0.85,\n            cost_score=0.80,\n            scalability=0.90,\n            operating_condition_compatibility=(\n                0.9 if spec.solvent in (Solvent.AQUEOUS, Solvent.MIXED) else 0.7\n            ),\n            reusability_score=0.5,\n            selectivity_factor=selectivity_factor,\n            physics_class="covalent_cavity",\n            composite_score=0.0,\n            confidence=0.80,\n            advantages=advantages,\n            limitations=limitations,\n            feasible=True,\n        )\n\n    def design(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> CrownEtherFabSpec:\n        """\n        Full crown ether / cryptand design.\n\n        1. Identify target cation\n        2. Size-match ranking\n        3. HSAB donor selection (aza/thia variants)\n        4. Cryptand upgrade evaluation\n        5. Selectivity estimation\n        """\n\n        spec_hash = hashlib.md5(str(spec).encode()).hexdigest()[:12]\n        target_ion, cation = self._identify_target_cation(spec)\n\n        if cation is None:\n            return self._empty_fab(spec_hash, "Cannot identify target cation")\n\n        # ── Step 1: Size-match ranking ──\n        ranked = select_best_crown(target_ion, require_water_soluble=False)\n        if not ranked:\n            return self._empty_fab(spec_hash, f"No host for {target_ion}")\n\n        best_host, combined, predicted_logK, _rationale = ranked[0]\n        sm = size_match_score(cation.ionic_radius_A, best_host.cavity_radius_A)\n\n        # ── Step 2: HSAB donor substitution ──\n        donor_sub = "none"\n        donor_sub_rationale = ""\n        hsab = hsab_donor_score(cation.hsab_class, best_host.donor_types)\n\n        if cation.hsab_class == "soft" and "S" not in best_host.donor_types:\n            # Look for thia variant — relax radius tolerance since HSAB\n            # benefit can overcome moderate size-match penalty\n            for h in ALL_HOSTS_LIST:\n                if h.host_class == "thia_crown" and abs(\n                    h.cavity_radius_A - cation.ionic_radius_A\n                ) < 0.4:\n                    best_host = h\n                    donor_sub = "thia"\n                    donor_sub_rationale = (\n                        f"Soft cation {target_ion}: S-donors preferred. "\n                        f"Switched to {h.common_name}."\n                    )\n                    break\n\n        elif cation.hsab_class == "borderline" and "N" not in best_host.donor_types:\n            for h in ALL_HOSTS_LIST:\n                if h.host_class == "aza_crown" and abs(\n                    h.cavity_radius_A - cation.ionic_radius_A\n                ) < 0.8:\n                    best_host = h\n                    donor_sub = "aza"\n                    donor_sub_rationale = (\n                        f"Borderline cation {target_ion}: N-donors improve binding. "\n                        f"Switched to {h.common_name}."\n                    )\n                    break\n\n        # ── Step 3: Cryptand upgrade evaluation ──\n        cryptand_upgrade = False\n        cryptand_rationale = ""\n\n        # Consider cryptand if: (a) selectivity needed, or (b) size-match is marginal\n        if spec.must_exclude or sm < 0.7:\n            for h in CRYPTANDS:\n                crypt_sm = size_match_score(\n                    cation.ionic_radius_A, h.cavity_radius_A\n                )\n                if crypt_sm > sm * 0.9:  # cryptand has competitive size-match\n                    crypt_logK = h.selectivity_profile.get(target_ion, 0)\n                    crown_logK = best_host.selectivity_profile.get(target_ion, 0)\n                    if crypt_logK > crown_logK:\n                        best_host = h\n                        sm = crypt_sm\n                        predicted_logK = crypt_logK\n                        cryptand_upgrade = True\n                        cryptand_rationale = (\n                            f"Cryptand [{h.common_name}] provides 3D encapsulation: "\n                            f"logK {crypt_logK:.1f} vs crown {crown_logK:.1f}. "\n                            f"Cryptate stabilization: "\n                            f"{h.cryptate_stabilization_kJ_mol:.0f} kJ/mol."\n                        )\n                        break\n\n        # ── Step 4: Update predicted logK from best host ──\n        known_logK = best_host.selectivity_profile.get(target_ion)\n        logK_source = "Izatt_measured" if known_logK else "estimated"\n        if known_logK:\n            predicted_logK = known_logK\n\n        # ── Step 5: Selectivity estimation ──\n        selectivity_ratio = 1.0\n        if spec.must_exclude:\n            for exc in spec.must_exclude:\n                competitor_logK = best_host.selectivity_profile.get(exc.species, 0)\n                if competitor_logK > 0 and predicted_logK > 0:\n                    ratio = 10 ** (predicted_logK - competitor_logK)\n                    selectivity_ratio = min(selectivity_ratio, ratio)\n\n        # ── Step 6: Size-match quality label ──\n        if sm > 0.9:\n            sm_quality = "excellent"\n        elif sm > 0.7:\n            sm_quality = "good"\n        elif sm > 0.4:\n            sm_quality = "moderate"\n        else:\n            sm_quality = "poor"\n\n        # ── Step 7: Synthesis and sourcing ──\n        steps = []\n        if best_host.commercial:\n            steps.append(f"Procure {best_host.common_name} from {best_host.common_suppliers[0]}")\n        else:\n            steps.append(f"Synthesize {best_host.common_name} via {best_host.synthesis_route}")\n\n        if donor_sub == "thia" and not best_host.commercial:\n            steps.append("Thia-crown synthesis: thiol-alkoxide Williamson condensation")\n        if donor_sub == "aza" and not best_host.commercial:\n            steps.append("Aza-crown synthesis: Richman-Atkins tosyl route")\n\n        validation = [\n            f"ITC: Ka for {target_ion} in target matrix",\n            f"Competitive ITC: selectivity vs major interferents",\n        ]\n        if spec.must_exclude:\n            for exc in spec.must_exclude:\n                validation.append(f"Selectivity assay: {target_ion} vs {exc.species}")\n\n        expected = {\n            "logK": predicted_logK,\n            "Ka_M_inv": 10 ** predicted_logK if predicted_logK < 15 else 1e15,\n            "selectivity_ratio": selectivity_ratio,\n            "binding_stoichiometry": "1:1",\n        }\n\n        return CrownEtherFabSpec(\n            material_system="crown_ether",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(\n                volume_A3=4/3 * math.pi * best_host.cavity_radius_A ** 3,\n                aperture_A=best_host.cavity_radius_A * 2,\n                depth_A=3.0 if not best_host.is_3d_cage else best_host.cavity_radius_A * 2,\n                max_internal_diameter_A=best_host.cavity_radius_A * 2,\n            ),\n            predicted_deviation_from_ideal_A=abs(\n                cation.ionic_radius_A - best_host.cavity_radius_A\n            ),\n            synthesis_steps=steps,\n            estimated_yield=0.70 if best_host.commercial else 0.40,\n            estimated_cost_per_unit=best_host.cost_per_gram_usd,\n            estimated_time="immediate" if best_host.commercial else "3–7 days",\n            validation_experiments=validation,\n            expected_observables=expected,\n            # Crown-specific\n            selected_host=best_host.common_name,\n            host_class=best_host.host_class,\n            cavity_radius_A=best_host.cavity_radius_A,\n            target_ion=target_ion,\n            ion_radius_A=cation.ionic_radius_A,\n            size_match_score=sm,\n            size_match_quality=sm_quality,\n            predicted_logK=predicted_logK,\n            logK_source=logK_source,\n            macrocyclic_stabilization_kJ_mol=best_host.macrocyclic_stabilization_kJ_mol,\n            cryptate_stabilization_kJ_mol=best_host.cryptate_stabilization_kJ_mol,\n            predicted_selectivity_ratio=selectivity_ratio,\n            hsab_compatibility=hsab_donor_score(\n                cation.hsab_class, best_host.donor_types\n            ),\n            donor_types_used=best_host.donor_types,\n            cryptand_upgrade=cryptand_upgrade,\n            cryptand_upgrade_rationale=cryptand_rationale,\n            donor_substitution=donor_sub,\n            donor_substitution_rationale=donor_sub_rationale,\n            smiles=best_host.smiles,\n            supplier=best_host.common_suppliers[0] if best_host.commercial else "custom synthesis",\n            catalog_note=f"{best_host.common_name}, {best_host.mw:.0f} g/mol",\n        )\n\n    def validate_design(self, fab: FabricationSpec) -> ValidationReport:\n        """Check crown/cryptand design for internal consistency."""\n\n        if not isinstance(fab, CrownEtherFabSpec):\n            return ValidationReport(\n                valid=False,\n                issues=["Not a CrownEtherFabSpec"],\n                warnings=[],\n            )\n\n        issues = []\n        warnings = []\n\n        if fab.size_match_score < 0.2:\n            issues.append(\n                f"Size match {fab.size_match_score:.2f} too poor — "\n                "binding will be negligible"\n            )\n\n        if fab.predicted_logK < 1.0:\n            warnings.append(\n                f"Weak binding predicted (logK={fab.predicted_logK:.1f})"\n            )\n\n        if fab.hsab_compatibility < 0.4:\n            warnings.append(\n                f"HSAB mismatch ({fab.hsab_compatibility:.2f}): "\n                "consider aza/thia variant"\n            )\n\n        if fab.predicted_selectivity_ratio < 10 and fab.target_ion:\n            warnings.append(\n                f"Low selectivity ratio ({fab.predicted_selectivity_ratio:.0f}×): "\n                "consider cryptand upgrade"\n            )\n\n        return ValidationReport(\n            valid=len(issues) == 0,\n            issues=issues,\n            warnings=warnings,\n            confidence=0.85 if fab.logK_source == "Izatt_measured" else 0.60,\n        )\n\n    # ─────────────────────────────────────────\n    # Internal\n    # ─────────────────────────────────────────\n\n    def _identify_target_cation(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> tuple[str, Optional[CationTarget]]:\n        """\n        Identify the target cation from the spec.\n\n        Strategy: match cavity radius to known cation radii.\n        If spec has donor positions with charge info, use that.\n        """\n\n        # Check if any donor has charge annotation suggesting the target\n        for donor in spec.donor_positions:\n            if donor.charge_state < 0:\n                # Anionic donor → cation is the target\n                continue\n\n        # Primary: cavity radius matching\n        # Convert spec cavity diameter to radius\n        spec_radius_A = spec.cavity_dimensions.max_internal_diameter_A / 2.0\n\n        best_match = None\n        best_delta = float("inf")\n\n        for symbol, cation in CATION_DB.items():\n            delta = abs(cation.ionic_radius_A - spec_radius_A)\n            if delta < best_delta:\n                best_delta = delta\n                best_match = (symbol, cation)\n\n        if best_match and best_delta < 1.0:\n            return best_match\n\n        # Fallback: use cavity volume to estimate\n        return "K+", CATION_DB["K+"]  # default to most common crown target\n\n    def _infeasible_score(self, reason: str) -> RealizationScore:\n        return RealizationScore(\n            material_system="crown_ether",\n            adapter_id="CrownEtherAdapter",\n            deviation_from_ideal=DeviationReport(\n                material_system="crown_ether",\n                element_deviations_A=[],\n                max_deviation_A=float("inf"),\n                mean_deviation_A=float("inf"),\n            ),\n            physics_fidelity=0.0,\n            feasible=False,\n            infeasibility_reason=reason,\n        )\n\n    def _empty_fab(self, spec_hash: str, reason: str) -> CrownEtherFabSpec:\n        return CrownEtherFabSpec(\n            material_system="crown_ether",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(0, 0, 0, 0),\n            predicted_deviation_from_ideal_A=float("inf"),\n            synthesis_steps=[f"DESIGN FAILED: {reason}"],\n        )\n\n\ndef _make_crown_capability() -> MaterialCapability:\n    """Build crown-ether-specific MaterialCapability."""\n    return MaterialCapability(\n        system_id="crown_ether",\n        physics_class="covalent_cavity",\n        adapter_class="CrownEtherAdapter",\n        min_pocket_size_nm=0.12,\n        max_pocket_size_nm=0.34,\n        achievable_symmetries=["Cn", "Cnv", "Dnh"],\n        max_donor_count=8,\n        donor_types_available=["O", "N", "S"],\n        positioning_precision_A=0.05,\n        rigidity_range=("semi-rigid", "rigid"),\n        pH_stability=(2.0, 12.0),\n        thermal_stability_K=(273.0, 500.0),\n        solvent_compatibility=["aqueous", "organic", "mixed"],\n        min_practical_scale="µmol",\n        max_practical_scale="kmol",\n        cost_per_unit_range=(1.50, 80.0),\n        typical_synthesis_time="immediate (commercial) to 7 days",\n        literature_validation_rate=0.85,\n        literature_examples=20000,\n        design_tools_available=["RDKit"],\n        known_strengths=[\n            "Size-match selectivity well-characterized (Izatt)",\n            "Many commercial options",\n            "HSAB-tunable via O/N/S donor substitution",\n            "Cryptand upgrade for enhanced selectivity",\n        ],\n        known_limitations=[\n            "Primarily cation-selective",\n            "Organic crown ethers can be toxic",\n            "Conformational flexibility in larger rings",\n        ],\n    )\n',
    'mabe/realization/ranker.py': '"""\nApplication-Aware Ranker — Layer 3 Integration.\n\nScores all registered adapters against an InteractionGeometrySpec,\nusing application-appropriate weight profiles. Handles both precision\nbinders (Class A: CD, crown, porphyrin) and bulk sorbents (Class D:\nlignin, SAP, MIP, resin) on the same composite scale.\n\nKey design decision: the ranker doesn\'t privilege precision over capacity.\nA remediation spec weights cost_per_kg_processed and capacity heavily,\ncausing a bulk sorbent to outscore a precision binder even though the\nbinder has higher physics_fidelity.\n\nOutput groups results by physics class so the user sees:\n    "Best precision binder: β-CD (composite=0.72)"\n    "Best bulk sorbent: dithiocarbamate-lignin (composite=0.85)"\n"""\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mabe.realization.models import (\n    ApplicationContext,\n    InteractionGeometrySpec,\n    RealizationScore,\n    RankedRealizations,\n)\n\n\n# ─────────────────────────────────────────────\n# Weight profiles\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass WeightProfile:\n    """Application-specific scoring weights."""\n\n    name: str\n\n    # Precision axes\n    w_physics_fidelity: float = 0.0\n    w_synthetic_accessibility: float = 0.0\n    w_cost_score: float = 0.0\n    w_scalability: float = 0.0\n    w_operating_conditions: float = 0.0\n    w_reusability: float = 0.0\n\n    # Bulk sorbent axes\n    w_capacity: float = 0.0\n    w_selectivity: float = 0.0\n    w_throughput: float = 0.0\n    w_regenerability: float = 0.0\n    w_cost_per_kg: float = 0.0\n\n    def total(self) -> float:\n        return (\n            self.w_physics_fidelity + self.w_synthetic_accessibility +\n            self.w_cost_score + self.w_scalability +\n            self.w_operating_conditions + self.w_reusability +\n            self.w_capacity + self.w_selectivity +\n            self.w_throughput + self.w_regenerability +\n            self.w_cost_per_kg\n        )\n\n\nWEIGHT_PROFILES: dict[str, WeightProfile] = {\n    "research": WeightProfile(\n        name="research",\n        w_physics_fidelity=0.40,\n        w_synthetic_accessibility=0.15,\n        w_cost_score=0.10,\n        w_scalability=0.05,\n        w_operating_conditions=0.05,\n        w_reusability=0.05,\n        w_selectivity=0.15,\n        w_capacity=0.05,\n    ),\n    "diagnostic": WeightProfile(\n        name="diagnostic",\n        w_physics_fidelity=0.30,\n        w_selectivity=0.30,\n        w_synthetic_accessibility=0.10,\n        w_cost_score=0.05,\n        w_scalability=0.05,\n        w_operating_conditions=0.10,\n        w_reusability=0.10,\n    ),\n    "separation": WeightProfile(\n        name="separation",\n        w_selectivity=0.25,\n        w_capacity=0.20,\n        w_throughput=0.15,\n        w_regenerability=0.15,\n        w_cost_per_kg=0.10,\n        w_physics_fidelity=0.10,\n        w_scalability=0.05,\n    ),\n    "remediation": WeightProfile(\n        name="remediation",\n        w_cost_per_kg=0.25,\n        w_capacity=0.25,\n        w_throughput=0.15,\n        w_regenerability=0.10,\n        w_selectivity=0.10,\n        w_scalability=0.10,\n        w_physics_fidelity=0.05,\n    ),\n}\n\n\ndef get_weight_profile(application: ApplicationContext) -> WeightProfile:\n    """Map ApplicationContext enum to weight profile."""\n    mapping = {\n        ApplicationContext.RESEARCH: "research",\n        ApplicationContext.DIAGNOSTIC: "diagnostic",\n        ApplicationContext.SEPARATION: "separation",\n        ApplicationContext.REMEDIATION: "remediation",\n    }\n    profile_name = mapping.get(application, "research")\n    return WEIGHT_PROFILES[profile_name]\n\n\n# ─────────────────────────────────────────────\n# Composite scoring\n# ─────────────────────────────────────────────\n\ndef compute_composite(score: RealizationScore, weights: WeightProfile) -> float:\n    """\n    Compute application-weighted composite score.\n\n    All axes are 0.0–1.0 normalized. Bulk sorbent fields are\n    normalized against reference values before weighting.\n    """\n    # Precision axes (already 0–1)\n    composite = 0.0\n    composite += weights.w_physics_fidelity * score.physics_fidelity\n    composite += weights.w_synthetic_accessibility * score.synthetic_accessibility\n    composite += weights.w_cost_score * score.cost_score\n    composite += weights.w_scalability * score.scalability\n    composite += weights.w_operating_conditions * score.operating_condition_compatibility\n    composite += weights.w_reusability * score.reusability_score\n\n    # Bulk sorbent axes — normalize against reference values\n    # Capacity: 5 mmol/g is excellent for most sorbents\n    cap_norm = min(1.0, score.capacity_mmol_per_g / 5.0) if score.capacity_mmol_per_g > 0 else 0.0\n    composite += weights.w_capacity * cap_norm\n\n    # Selectivity: log scale, 100× is excellent\n    import math\n    sel_norm = min(1.0, math.log10(max(1.0, score.selectivity_factor)) / 2.0)\n    composite += weights.w_selectivity * sel_norm\n\n    # Throughput: 100 L/h/kg is excellent for column operation\n    tp_norm = min(1.0, score.throughput_L_per_h_per_kg / 100.0) if score.throughput_L_per_h_per_kg > 0 else 0.0\n    composite += weights.w_throughput * tp_norm\n\n    # Regenerability: 50 cycles is excellent\n    regen_norm = min(1.0, score.regenerability_cycles / 50.0) if score.regenerability_cycles > 0 else 0.0\n    composite += weights.w_regenerability * regen_norm\n\n    # Cost per kg processed: inverted (lower is better). $10/kg is excellent.\n    if score.cost_per_kg_processed > 0:\n        cost_norm = min(1.0, 10.0 / score.cost_per_kg_processed)\n    else:\n        cost_norm = 0.0\n    composite += weights.w_cost_per_kg * cost_norm\n\n    return composite\n\n\n# ─────────────────────────────────────────────\n# Ranked output with physics class grouping\n# ─────────────────────────────────────────────\n\n@dataclass\nclass GroupedRanking:\n    """Rankings grouped by physics class."""\n    physics_class: str\n    class_label: str             # human-readable: "Precision Binder", "Bulk Sorbent"\n    rankings: list[RealizationScore]\n    best: Optional[RealizationScore] = None\n\n\n@dataclass\nclass RankerOutput:\n    """Full ranker output with application context."""\n\n    spec: InteractionGeometrySpec\n    application: ApplicationContext\n    weight_profile: WeightProfile\n\n    # ── All scores, sorted by composite ──\n    all_rankings: list[RealizationScore]\n\n    # ── Grouped by physics class ──\n    groups: list[GroupedRanking]\n\n    # ── Overall recommendation ──\n    recommended_system: str\n    recommended_adapter: str\n    recommendation_rationale: str\n\n\n# ─────────────────────────────────────────────\n# Ranker\n# ─────────────────────────────────────────────\n\nPHYSICS_CLASS_LABELS = {\n    "covalent_cavity": "Precision Binder",\n    "bulk_sorbent": "Bulk Sorbent",\n    "periodic_lattice": "Periodic Framework",\n    "foldable_polymer": "Foldable Polymer",\n    "emergent_cavity": "Self-Assembled Cage",\n}\n\n\nclass AdapterRanker:\n    """\n    Application-aware ranker. Scores all registered adapters and\n    groups results by physics class.\n    """\n\n    def __init__(self, adapters: list = None):\n        """\n        Args:\n            adapters: list of RealizationAdapter instances to rank.\n                      If None, auto-discover from AdapterRegistry.\n        """\n        self._adapters = adapters or []\n\n    def add_adapter(self, adapter) -> None:\n        self._adapters.append(adapter)\n\n    def rank(\n        self,\n        spec: InteractionGeometrySpec,\n        application: Optional[ApplicationContext] = None,\n        custom_weights: Optional[WeightProfile] = None,\n    ) -> RankerOutput:\n        """\n        Score all adapters against spec, return grouped rankings.\n\n        Args:\n            spec: the interaction geometry to realize\n            application: if None, uses spec.target_application\n            custom_weights: override default weight profile\n        """\n        app = application or spec.target_application or ApplicationContext.RESEARCH\n        weights = custom_weights or get_weight_profile(app)\n\n        # ── Score all adapters ──\n        scores: list[RealizationScore] = []\n        for adapter in self._adapters:\n            try:\n                score = adapter.estimate_fidelity(spec)\n                if not score.physics_class:\n                    score.physics_class = adapter.capability.physics_class\n                score.composite_score = compute_composite(score, weights)\n                scores.append(score)\n            except Exception:\n                # Adapter failed — skip, don\'t crash the ranker\n                continue\n\n        # ── Sort by composite ──\n        scores.sort(key=lambda s: s.composite_score, reverse=True)\n\n        # ── Group by physics class ──\n        class_groups: dict[str, list[RealizationScore]] = {}\n        for s in scores:\n            cls = s.physics_class or "unknown"\n            class_groups.setdefault(cls, []).append(s)\n\n        groups = []\n        for cls, cls_scores in class_groups.items():\n            cls_scores.sort(key=lambda s: s.composite_score, reverse=True)\n            feasible = [s for s in cls_scores if s.feasible]\n            best = feasible[0] if feasible else None\n            groups.append(GroupedRanking(\n                physics_class=cls,\n                class_label=PHYSICS_CLASS_LABELS.get(cls, cls),\n                rankings=cls_scores,\n                best=best,\n            ))\n\n        # Sort groups so highest-scoring class comes first\n        groups.sort(\n            key=lambda g: g.best.composite_score if g.best else 0.0,\n            reverse=True,\n        )\n\n        # ── Recommendation ──\n        feasible_scores = [s for s in scores if s.feasible]\n        if feasible_scores:\n            best = feasible_scores[0]\n            rec_system = best.material_system\n            rec_adapter = best.adapter_id\n            rec_rationale = _build_rationale(best, weights, groups)\n        else:\n            rec_system = "none"\n            rec_adapter = "none"\n            rec_rationale = "No feasible adapter found."\n\n        return RankerOutput(\n            spec=spec,\n            application=app,\n            weight_profile=weights,\n            all_rankings=scores,\n            groups=groups,\n            recommended_system=rec_system,\n            recommended_adapter=rec_adapter,\n            recommendation_rationale=rec_rationale,\n        )\n\n\ndef _build_rationale(\n    best: RealizationScore,\n    weights: WeightProfile,\n    groups: list[GroupedRanking],\n) -> str:\n    """Build human-readable recommendation rationale."""\n    parts = [\n        f"Recommended: {best.material_system} "\n        f"(composite={best.composite_score:.3f}, "\n        f"profile={weights.name})"\n    ]\n\n    if best.advantages:\n        parts.append(f"Strengths: {\'; \'.join(best.advantages[:3])}")\n\n    # Note if another physics class is competitive\n    for g in groups:\n        if g.best and g.best.material_system != best.material_system:\n            delta = best.composite_score - g.best.composite_score\n            if delta < 0.15:\n                parts.append(\n                    f"Note: {g.class_label} option "\n                    f"({g.best.material_system}, "\n                    f"composite={g.best.composite_score:.3f}) "\n                    f"is competitive"\n                )\n\n    return " | ".join(parts)\n',
    'mabe/realization/adapter_registry.py': '"""\nAdapter Registry — maps system_id to concrete adapter classes.\n\nLazy instantiation: adapters are only created when needed.\nAuto-discovery: register_builtins() wires all implemented adapters.\n\nUsage:\n    registry = AdapterRegistry()\n    registry.register_builtins()\n    adapters = registry.instantiate_all()\n    ranker = AdapterRanker(adapters)\n    result = ranker.rank(spec)\n"""\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Type\n\nfrom mabe.realization.adapters.base import RealizationAdapter\n\n\nclass AdapterRegistry:\n    """Maps system_id → adapter class. Lazy instantiation."""\n\n    def __init__(self):\n        self._registry: dict[str, Type[RealizationAdapter]] = {}\n        self._instances: dict[str, RealizationAdapter] = {}\n\n    def register(self, system_id: str, adapter_cls: Type[RealizationAdapter]) -> None:\n        """Register an adapter class for a system_id."""\n        self._registry[system_id] = adapter_cls\n\n    def get_class(self, system_id: str) -> Optional[Type[RealizationAdapter]]:\n        return self._registry.get(system_id)\n\n    def instantiate(self, system_id: str) -> Optional[RealizationAdapter]:\n        """Get or create adapter instance."""\n        if system_id in self._instances:\n            return self._instances[system_id]\n        cls = self._registry.get(system_id)\n        if cls is None:\n            return None\n        instance = cls()\n        self._instances[system_id] = instance\n        return instance\n\n    def instantiate_all(self) -> list[RealizationAdapter]:\n        """Instantiate all registered adapters."""\n        result = []\n        for system_id in self._registry:\n            adapter = self.instantiate(system_id)\n            if adapter is not None:\n                result.append(adapter)\n        return result\n\n    def registered_ids(self) -> list[str]:\n        return list(self._registry.keys())\n\n    def __len__(self) -> int:\n        return len(self._registry)\n\n    def __contains__(self, system_id: str) -> bool:\n        return system_id in self._registry\n\n\ndef register_builtins(registry: AdapterRegistry) -> AdapterRegistry:\n    """\n    Register all implemented adapters.\n\n    Each adapter is imported and registered lazily so missing\n    dependencies don\'t prevent other adapters from loading.\n    """\n    # ── Class A: Precision Binders ──\n    try:\n        from mabe.realization.adapters.cyclodextrin_adapter import CyclodextrinAdapter\n        registry.register("cyclodextrin", CyclodextrinAdapter)\n    except ImportError:\n        pass\n\n    try:\n        from mabe.realization.adapters.crown_ether_adapter import CrownEtherAdapter\n        registry.register("crown_ether", CrownEtherAdapter)\n    except ImportError:\n        pass\n\n    try:\n        from mabe.realization.adapters.porphyrin_adapter import PorphyrinAdapter\n        registry.register("porphyrin", PorphyrinAdapter)\n    except ImportError:\n        pass\n\n    # ── Class D: Bulk Sorbents ──\n    try:\n        from mabe.realization.adapters.lignin_adapter import FunctionalizedLigninAdapter\n        registry.register("functionalized_lignin", FunctionalizedLigninAdapter)\n    except ImportError:\n        pass\n\n    return registry\n\n\n# ─────────────────────────────────────────────\n# Convenience: global registry\n# ─────────────────────────────────────────────\n\nADAPTER_REGISTRY = AdapterRegistry()\nregister_builtins(ADAPTER_REGISTRY)\n',
    'mabe/realization/adapters/lignin_adapter.py': '"""\nFunctionalized Lignin Adapter — Class D (Bulk Sorbent).\n\nTakes an InteractionGeometrySpec and designs a functionalized lignin sorbent.\nThe spec drives functional group selection through the same HSAB and donor\nsubtype logic used by precision binders.\n\nDesign logic:\n    1. Spec donor types → functional group selection (HSAB-matched)\n    2. Spec cavity size → target loading density (groups/g)\n    3. Application context → backbone grade + crosslinker selection\n    4. Physics predicts capacity from: group_density × site_Ka × accessibility\n    5. FabSpec includes functionalization chemistry, not just "use lignin"\n\nPhysics connection:\n    - Same HSAB donor routing as crown ether adapter\n    - Same BackSolve donor subtypes (O_carboxylate, S_thiolate, N_amine, etc.)\n    - Capacity = f(functional_group_density, per_site_Ka, accessibility)\n    - Selectivity from donor preference ratios\n\nData sources:\n    - Guo X et al. (Chem. Eng. J. 2020) — lignin-based heavy metal sorbents\n    - Wang J, Chen C (Biotechnol. Adv. 2009) — biosorbent review\n    - Ge Y et al. (J. Environ. Chem. Eng. 2016) — modified lignin for Pb removal\n    - Suhas et al. (Bioresour. Technol. 2007) — lignin as sorbent\n"""\n\nfrom __future__ import annotations\n\nimport hashlib\nimport math\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mabe.realization.adapters.base import RealizationAdapter, ValidationReport\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    DeviationReport,\n    FabricationSpec,\n    InteractionGeometrySpec,\n    RealizationScore,\n    Solvent,\n)\nfrom mabe.realization.registry.material_registry import MaterialCapability\n\n\n# ─────────────────────────────────────────────\n# Functional group library (physics-driven)\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass FunctionalGroup:\n    """A graftable functional group for lignin functionalization."""\n\n    name: str\n    abbreviation: str\n    donor_atom: str                    # "O", "N", "S"\n    donor_subtype: str                 # BackSolve subtype\n    hsab_affinity: str                 # "hard", "borderline", "soft"\n\n    # ── Performance ──\n    typical_loading_mmol_per_g: float  # achievable grafting density\n    typical_qmax_mg_per_g: float       # for Pb²⁺ as reference\n    typical_logK_site: float           # per-site binding constant\n    selectivity_metals: list[str]      # metals this group prefers\n\n    # ── Chemistry ──\n    grafting_reagent: str\n    grafting_conditions: str\n    grafting_yield: float              # 0–1\n\n    # ── Cost ──\n    reagent_cost_per_kg_usd: float\n    process_cost_per_kg_sorbent_usd: float\n\n\nFUNCTIONAL_GROUPS: dict[str, FunctionalGroup] = {\n    "carboxylate": FunctionalGroup(\n        name="Carboxylate (–COOH)",\n        abbreviation="COOH",\n        donor_atom="O",\n        donor_subtype="O_carboxylate",\n        hsab_affinity="hard",\n        typical_loading_mmol_per_g=3.5,\n        typical_qmax_mg_per_g=45.0,\n        typical_logK_site=3.2,\n        selectivity_metals=["Ca2+", "Mg2+", "La3+", "UO2_2+", "Cu2+"],\n        grafting_reagent="chloroacetic acid (ClCH2COOH)",\n        grafting_conditions="NaOH (40%), 60°C, 4h",\n        grafting_yield=0.75,\n        reagent_cost_per_kg_usd=2.00,\n        process_cost_per_kg_sorbent_usd=5.00,\n    ),\n    "phosphonate": FunctionalGroup(\n        name="Phosphonate (–PO3H2)",\n        abbreviation="PO3H2",\n        donor_atom="O",\n        donor_subtype="O_phosphonate",\n        hsab_affinity="hard",\n        typical_loading_mmol_per_g=2.0,\n        typical_qmax_mg_per_g=55.0,\n        typical_logK_site=4.0,\n        selectivity_metals=["UO2_2+", "La3+", "Ca2+", "Fe3+"],\n        grafting_reagent="phosphorous acid + formaldehyde (Mannich)",\n        grafting_conditions="85°C, 6h, aqueous",\n        grafting_yield=0.60,\n        reagent_cost_per_kg_usd=8.00,\n        process_cost_per_kg_sorbent_usd=15.00,\n    ),\n    "amine": FunctionalGroup(\n        name="Amine (–NH2)",\n        abbreviation="NH2",\n        donor_atom="N",\n        donor_subtype="N_amine",\n        hsab_affinity="borderline",\n        typical_loading_mmol_per_g=4.0,\n        typical_qmax_mg_per_g=65.0,\n        typical_logK_site=3.8,\n        selectivity_metals=["Cu2+", "Ni2+", "Zn2+", "Co2+", "Pb2+"],\n        grafting_reagent="ethylenediamine (EDA)",\n        grafting_conditions="Mannich reaction: HCHO + EDA, 70°C, 8h",\n        grafting_yield=0.70,\n        reagent_cost_per_kg_usd=3.00,\n        process_cost_per_kg_sorbent_usd=8.00,\n    ),\n    "iminodiacetate": FunctionalGroup(\n        name="Iminodiacetate (–N(CH2COOH)2)",\n        abbreviation="IDA",\n        donor_atom="N",\n        donor_subtype="N_amine",\n        hsab_affinity="borderline",\n        typical_loading_mmol_per_g=2.5,\n        typical_qmax_mg_per_g=80.0,\n        typical_logK_site=5.0,\n        selectivity_metals=["Cu2+", "Ni2+", "Zn2+", "Co2+", "Pb2+"],\n        grafting_reagent="chloroacetic acid + ammonia",\n        grafting_conditions="Two-step: amination then carboxymethylation",\n        grafting_yield=0.55,\n        reagent_cost_per_kg_usd=5.00,\n        process_cost_per_kg_sorbent_usd=12.00,\n    ),\n    "dithiocarbamate": FunctionalGroup(\n        name="Dithiocarbamate (–NCS2⁻)",\n        abbreviation="DTC",\n        donor_atom="S",\n        donor_subtype="S_thiolate",\n        hsab_affinity="soft",\n        typical_loading_mmol_per_g=2.8,\n        typical_qmax_mg_per_g=120.0,  # excellent for Pb, Hg, Cd\n        typical_logK_site=5.5,\n        selectivity_metals=["Pb2+", "Hg2+", "Cd2+", "Ag+", "Cu2+"],\n        grafting_reagent="CS2 + amine (on aminated lignin)",\n        grafting_conditions="CS2 in NaOH, 25°C, 2h (on pre-aminated lignin)",\n        grafting_yield=0.65,\n        reagent_cost_per_kg_usd=6.00,\n        process_cost_per_kg_sorbent_usd=18.00,\n    ),\n    "thiol": FunctionalGroup(\n        name="Thiol (–SH)",\n        abbreviation="SH",\n        donor_atom="S",\n        donor_subtype="S_thiolate",\n        hsab_affinity="soft",\n        typical_loading_mmol_per_g=2.0,\n        typical_qmax_mg_per_g=95.0,\n        typical_logK_site=5.2,\n        selectivity_metals=["Hg2+", "Pb2+", "Cd2+", "Ag+"],\n        grafting_reagent="thioglycolic acid or 2-mercaptoethanol",\n        grafting_conditions="Esterification with phenolic OH, 80°C, 6h",\n        grafting_yield=0.50,\n        reagent_cost_per_kg_usd=12.00,\n        process_cost_per_kg_sorbent_usd=22.00,\n    ),\n}\n\n\n# ─────────────────────────────────────────────\n# Lignin backbone library\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass LigninBackbone:\n    """Lignin source/grade with base properties."""\n\n    name: str\n    source: str                        # "kraft", "organosolv", "soda", "lignosulfonate"\n    phenolic_OH_mmol_per_g: float\n    aliphatic_OH_mmol_per_g: float\n    COOH_mmol_per_g: float\n    mw_avg: float                      # number-average MW\n    cost_per_kg_usd: float\n    water_soluble: bool\n    suppliers: list[str]\n\n\nLIGNIN_BACKBONES: dict[str, LigninBackbone] = {\n    "kraft": LigninBackbone(\n        name="Kraft lignin",\n        source="kraft",\n        phenolic_OH_mmol_per_g=4.2,\n        aliphatic_OH_mmol_per_g=2.8,\n        COOH_mmol_per_g=0.6,\n        mw_avg=5000,\n        cost_per_kg_usd=0.50,\n        water_soluble=False,\n        suppliers=["Domtar", "Stora Enso", "West Fraser"],\n    ),\n    "organosolv": LigninBackbone(\n        name="Organosolv lignin",\n        source="organosolv",\n        phenolic_OH_mmol_per_g=3.8,\n        aliphatic_OH_mmol_per_g=3.5,\n        COOH_mmol_per_g=0.3,\n        mw_avg=3000,\n        cost_per_kg_usd=3.00,\n        water_soluble=False,\n        suppliers=["Suzano", "Lignol"],\n    ),\n    "lignosulfonate": LigninBackbone(\n        name="Lignosulfonate",\n        source="lignosulfonate",\n        phenolic_OH_mmol_per_g=2.0,\n        aliphatic_OH_mmol_per_g=1.5,\n        COOH_mmol_per_g=0.8,\n        mw_avg=20000,\n        cost_per_kg_usd=0.30,\n        water_soluble=True,\n        suppliers=["Borregaard", "Sappi"],\n    ),\n}\n\n\n# ─────────────────────────────────────────────\n# Crosslinker library\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass Crosslinker:\n    """Crosslinker for insolubilizing lignin."""\n\n    name: str\n    mechanism: str                     # "Schiff base", "epoxide ring opening", etc.\n    pH_stability: tuple[float, float]\n    thermal_limit_C: float\n    cost_per_kg_usd: float\n    typical_wt_pct: float              # typical loading\n\n\nCROSSLINKERS: dict[str, Crosslinker] = {\n    "glutaraldehyde": Crosslinker(\n        name="Glutaraldehyde",\n        mechanism="Schiff base with amine groups",\n        pH_stability=(2.0, 10.0),\n        thermal_limit_C=120.0,\n        cost_per_kg_usd=5.00,\n        typical_wt_pct=15.0,\n    ),\n    "epichlorohydrin": Crosslinker(\n        name="Epichlorohydrin",\n        mechanism="Epoxide ring opening with –OH",\n        pH_stability=(1.0, 12.0),\n        thermal_limit_C=150.0,\n        cost_per_kg_usd=3.00,\n        typical_wt_pct=20.0,\n    ),\n    "formaldehyde": Crosslinker(\n        name="Formaldehyde",\n        mechanism="Methylene bridge with phenolic ring",\n        pH_stability=(1.0, 13.0),\n        thermal_limit_C=200.0,\n        cost_per_kg_usd=1.00,\n        typical_wt_pct=10.0,\n    ),\n}\n\n\n# ─────────────────────────────────────────────\n# HSAB routing: spec donors → functional groups\n# ─────────────────────────────────────────────\n\n# Maps cation HSAB class to preferred functional group\nHSAB_GROUP_ROUTING: dict[str, list[str]] = {\n    "hard": ["carboxylate", "phosphonate"],\n    "borderline": ["amine", "iminodiacetate"],\n    "soft": ["dithiocarbamate", "thiol"],\n}\n\n# Simplified cation HSAB lookup (subset for bulk sorbent targets)\nCATION_HSAB: dict[str, str] = {\n    "Li+": "hard", "Na+": "hard", "K+": "hard",\n    "Mg2+": "hard", "Ca2+": "hard", "Sr2+": "hard", "Ba2+": "hard",\n    "Fe3+": "hard", "La3+": "hard", "UO2_2+": "hard",\n    "Cu2+": "borderline", "Zn2+": "borderline", "Ni2+": "borderline",\n    "Co2+": "borderline", "Mn2+": "borderline",\n    "Pb2+": "soft", "Cd2+": "soft", "Hg2+": "soft", "Ag+": "soft",\n}\n\n\ndef select_functional_group(\n    spec: InteractionGeometrySpec,\n) -> tuple[FunctionalGroup, str]:\n    """\n    Select functional group from spec donor types via HSAB routing.\n\n    Uses same logic as precision adapters: donor atom types in spec\n    indicate required HSAB class.\n    """\n    donor_types = spec.required_donor_types\n\n    # Infer HSAB preference from donor types\n    if "S" in donor_types:\n        hsab_class = "soft"\n    elif "N" in donor_types and "O" not in donor_types:\n        hsab_class = "borderline"\n    elif "N" in donor_types and "O" in donor_types:\n        hsab_class = "borderline"\n    elif "O" in donor_types:\n        hsab_class = "hard"\n    else:\n        # Default: check cavity size to guess cation\n        hsab_class = _guess_hsab_from_cavity(spec)\n\n    group_names = HSAB_GROUP_ROUTING.get(hsab_class, ["carboxylate"])\n    selected = FUNCTIONAL_GROUPS[group_names[0]]\n\n    rationale = (\n        f"HSAB routing: {hsab_class} → {selected.abbreviation} "\n        f"({selected.donor_subtype}). "\n        f"Donor types in spec: {donor_types or \'none (inferred from cavity)\'}."\n    )\n\n    return selected, rationale\n\n\ndef _guess_hsab_from_cavity(spec: InteractionGeometrySpec) -> str:\n    """\n    Guess HSAB class from cavity size when donor types aren\'t specified.\n\n    Small cavity → likely transition metal (borderline).\n    Medium cavity → likely divalent main group (hard/soft depends).\n    Large cavity → likely alkali/alkaline earth (hard).\n    """\n    diameter = spec.cavity_dimensions.max_internal_diameter_A\n    if diameter < 1.5:\n        return "borderline"  # small TM\n    elif diameter > 3.0:\n        return "hard"  # large alkali\n    else:\n        return "borderline"  # default\n\n\n# ─────────────────────────────────────────────\n# LigninFabSpec\n# ─────────────────────────────────────────────\n\n@dataclass\nclass LigninFabSpec(FabricationSpec):\n    """Fabrication spec for functionalized lignin sorbent."""\n\n    # ── Backbone ──\n    backbone: str = ""\n    backbone_source: str = ""\n    backbone_cost_per_kg: float = 0.0\n\n    # ── Functionalization ──\n    functional_group: str = ""\n    functional_group_abbreviation: str = ""\n    donor_subtype: str = ""\n    hsab_class: str = ""\n    target_loading_mmol_per_g: float = 0.0\n    grafting_reagent: str = ""\n    grafting_conditions: str = ""\n\n    # ── Crosslinker ──\n    crosslinker: str = ""\n    crosslinker_wt_pct: float = 0.0\n    pH_stability: tuple[float, float] = (2.0, 10.0)\n\n    # ── Predicted performance ──\n    predicted_qmax_mg_per_g: float = 0.0\n    predicted_qmax_mmol_per_g: float = 0.0\n    predicted_logK_site: float = 0.0\n    predicted_selectivity_vs: dict[str, float] = field(default_factory=dict)\n\n    # ── Economics ──\n    sorbent_cost_per_kg: float = 0.0\n    predicted_cost_per_kg_removed: float = 0.0\n    predicted_regeneration_cycles: int = 0\n\n    # ── Process design ──\n    recommended_column_config: str = ""\n    contact_time_min: float = 0.0\n    optimal_pH: float = 0.0\n\n\n# ─────────────────────────────────────────────\n# Adapter\n# ─────────────────────────────────────────────\n\nclass FunctionalizedLigninAdapter(RealizationAdapter):\n    """\n    Designs functionalized lignin sorbents from InteractionGeometrySpec.\n\n    Class D (Bulk Sorbent):\n        - Physics drives functional group selection (HSAB routing)\n        - Capacity from group_density × site_Ka × accessibility\n        - Cost metric is $/kg of target removed\n        - Same donor subtype logic as precision adapters\n    """\n\n    def __init__(self, capability: Optional[MaterialCapability] = None):\n        if capability is None:\n            capability = _make_lignin_capability()\n        super().__init__(capability)\n\n    def estimate_fidelity(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> RealizationScore:\n        """Quick score for the ranker."""\n\n        func_group, rationale = select_functional_group(spec)\n\n        # Physics fidelity: how well can we approximate the spec geometry?\n        # Bulk sorbents have distributed sites — modest fidelity but high capacity\n        physics_fidelity = 0.3  # base for any sorbent\n\n        # Bonus if donor types match well\n        if spec.required_donor_types:\n            donor_match = len(\n                spec.required_donor_types & {func_group.donor_atom}\n            ) / max(1, len(spec.required_donor_types))\n            physics_fidelity += donor_match * 0.2\n\n        # Capacity estimate\n        capacity = func_group.typical_loading_mmol_per_g * 0.8  # 80% accessibility\n\n        # Selectivity from group preference\n        selectivity = 10.0 ** (func_group.typical_logK_site - 2.0)  # vs generic competitor\n\n        # Cost per kg removed\n        sorbent_cost = (\n            LIGNIN_BACKBONES["kraft"].cost_per_kg_usd +\n            func_group.process_cost_per_kg_sorbent_usd\n        )\n        qmax_kg = func_group.typical_qmax_mg_per_g / 1000.0  # mg/g → g/g → kg/kg\n        regen_cycles = 15\n        cost_per_kg = sorbent_cost / (qmax_kg * regen_cycles) if qmax_kg > 0 else 999.0\n\n        advantages = [\n            f"Lignin: $0.50/kg renewable backbone",\n            f"{func_group.abbreviation} group: {func_group.typical_qmax_mg_per_g:.0f} mg/g capacity",\n            "Scalable to tonnes",\n        ]\n        limitations = [\n            "Distributed binding sites — lower selectivity than precision binders",\n            f"Physics fidelity {physics_fidelity:.2f} (bulk approximation)",\n        ]\n\n        deviation = DeviationReport(\n            material_system="functionalized_lignin",\n            element_deviations_A=[],\n            max_deviation_A=1.0,\n            mean_deviation_A=1.0,\n        )\n\n        return RealizationScore(\n            material_system="functionalized_lignin",\n            adapter_id="FunctionalizedLigninAdapter",\n            deviation_from_ideal=deviation,\n            physics_fidelity=physics_fidelity,\n            synthetic_accessibility=0.90,\n            cost_score=0.90,\n            scalability=0.95,\n            operating_condition_compatibility=0.80,\n            reusability_score=0.60,\n            # Bulk sorbent fields\n            capacity_mmol_per_g=capacity,\n            selectivity_factor=selectivity,\n            throughput_L_per_h_per_kg=50.0,  # typical packed column\n            regenerability_cycles=regen_cycles,\n            cost_per_kg_processed=cost_per_kg,\n            physics_class="bulk_sorbent",\n            composite_score=0.0,\n            confidence=0.70,\n            advantages=advantages,\n            limitations=limitations,\n            feasible=True,\n        )\n\n    def design(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> LigninFabSpec:\n        """Full lignin sorbent design driven by spec physics."""\n\n        spec_hash = hashlib.md5(str(spec).encode()).hexdigest()[:12]\n\n        # ── Step 1: Functional group from HSAB routing ──\n        func_group, group_rationale = select_functional_group(spec)\n\n        # ── Step 2: Backbone selection ──\n        backbone = LIGNIN_BACKBONES["kraft"]  # cheapest, most available\n        if func_group.hsab_affinity == "soft":\n            # Need more phenolic OH for thiol/DTC grafting\n            if LIGNIN_BACKBONES["kraft"].phenolic_OH_mmol_per_g < 3.0:\n                backbone = LIGNIN_BACKBONES["organosolv"]\n\n        # ── Step 3: Crosslinker selection ──\n        if func_group.donor_atom == "N":\n            crosslinker = CROSSLINKERS["glutaraldehyde"]\n        else:\n            crosslinker = CROSSLINKERS["epichlorohydrin"]\n\n        # ── Step 4: Capacity prediction ──\n        loading = func_group.typical_loading_mmol_per_g * func_group.grafting_yield\n        accessibility = 0.80  # 80% of grafted sites accessible\n        effective_loading = loading * accessibility\n        qmax_mmol = effective_loading\n        # Convert to mg/g using Pb²⁺ MW as reference (207.2 g/mol)\n        target_mw = 207.2  # default Pb²⁺; spec could override\n        qmax_mg = qmax_mmol * target_mw\n\n        # ── Step 5: Cost calculation ──\n        sorbent_cost = backbone.cost_per_kg_usd + func_group.process_cost_per_kg_sorbent_usd\n        regen_cycles = 15\n        qmax_kg_per_kg = qmax_mg / 1e6  # mg/g → kg/kg\n        cost_per_kg_removed = (\n            sorbent_cost / (qmax_kg_per_kg * regen_cycles)\n            if qmax_kg_per_kg > 0 else 999.0\n        )\n\n        # ── Step 6: Synthesis steps ──\n        steps = [\n            f"Procure {backbone.name} (${backbone.cost_per_kg_usd}/kg) from {backbone.suppliers[0]}",\n        ]\n\n        # Functionalization may be multi-step\n        if func_group.abbreviation == "DTC":\n            steps.append(\n                f"Step 1 — Amination: Mannich reaction "\n                f"(HCHO + EDA, 70°C, 8h) to introduce –NH₂ groups"\n            )\n            steps.append(\n                f"Step 2 — DTC grafting: {func_group.grafting_conditions}"\n            )\n        else:\n            steps.append(\n                f"Functionalize: {func_group.grafting_reagent}, "\n                f"{func_group.grafting_conditions}"\n            )\n\n        steps.append(\n            f"Crosslink: {crosslinker.name} at {crosslinker.typical_wt_pct:.0f} wt%, "\n            f"{crosslinker.mechanism}"\n        )\n        steps.append("Wash (water, ethanol), dry (60°C, 12h), grind to 0.5–1.0 mm")\n        steps.append(\n            "Characterize: FTIR (confirm functional groups), "\n            "BET surface area, elemental analysis (N or S content)"\n        )\n\n        # ── Step 7: Validation plan ──\n        validation = [\n            f"Batch adsorption isotherm: 10–500 ppm target in pH-buffered solution",\n            "Langmuir/Freundlich fit → qmax, KL",\n            "Kinetics: pseudo-second-order, contact time optimization",\n            "Column breakthrough: 10 bed volumes, measure Ct/C0",\n        ]\n        if regen_cycles > 1:\n            validation.append(\n                f"Regeneration: 0.1M HNO₃ wash, measure capacity over {regen_cycles} cycles"\n            )\n\n        # pH for optimal binding\n        if func_group.hsab_affinity == "hard":\n            optimal_pH = 5.5\n        elif func_group.hsab_affinity == "soft":\n            optimal_pH = 5.0\n        else:\n            optimal_pH = 5.5\n\n        expected = {\n            "qmax_mg_per_g": qmax_mg,\n            "qmax_mmol_per_g": qmax_mmol,\n            "logK_site": func_group.typical_logK_site,\n            "optimal_pH": optimal_pH,\n            "contact_time_min": 60.0,\n            "sorbent_cost_per_kg": sorbent_cost,\n            "cost_per_kg_removed_usd": cost_per_kg_removed,\n        }\n\n        return LigninFabSpec(\n            material_system="functionalized_lignin",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(\n                volume_A3=0, aperture_A=0, depth_A=0, max_internal_diameter_A=0,\n            ),\n            predicted_deviation_from_ideal_A=1.0,\n            synthesis_steps=steps,\n            estimated_yield=func_group.grafting_yield,\n            estimated_cost_per_unit=sorbent_cost,\n            estimated_time="2–3 days",\n            validation_experiments=validation,\n            expected_observables=expected,\n            # Lignin-specific\n            backbone=backbone.name,\n            backbone_source=backbone.source,\n            backbone_cost_per_kg=backbone.cost_per_kg_usd,\n            functional_group=func_group.name,\n            functional_group_abbreviation=func_group.abbreviation,\n            donor_subtype=func_group.donor_subtype,\n            hsab_class=func_group.hsab_affinity,\n            target_loading_mmol_per_g=loading,\n            grafting_reagent=func_group.grafting_reagent,\n            grafting_conditions=func_group.grafting_conditions,\n            crosslinker=crosslinker.name,\n            crosslinker_wt_pct=crosslinker.typical_wt_pct,\n            pH_stability=crosslinker.pH_stability,\n            predicted_qmax_mg_per_g=qmax_mg,\n            predicted_qmax_mmol_per_g=qmax_mmol,\n            predicted_logK_site=func_group.typical_logK_site,\n            sorbent_cost_per_kg=sorbent_cost,\n            predicted_cost_per_kg_removed=cost_per_kg_removed,\n            predicted_regeneration_cycles=regen_cycles,\n            recommended_column_config="Packed bed, 0.5–1.0 mm particles, EBCT=5 min",\n            contact_time_min=60.0,\n            optimal_pH=optimal_pH,\n        )\n\n    def validate_design(self, fab: FabricationSpec) -> ValidationReport:\n        if not isinstance(fab, LigninFabSpec):\n            return ValidationReport(\n                valid=False, issues=["Not a LigninFabSpec"], warnings=[],\n            )\n\n        issues = []\n        warnings = []\n\n        if fab.target_loading_mmol_per_g < 0.5:\n            issues.append("Loading too low — insufficient capacity")\n\n        if fab.predicted_qmax_mg_per_g < 10:\n            warnings.append(f"Low capacity ({fab.predicted_qmax_mg_per_g:.0f} mg/g)")\n\n        if fab.predicted_cost_per_kg_removed > 100:\n            warnings.append(\n                f"High cost (${fab.predicted_cost_per_kg_removed:.0f}/kg removed)"\n            )\n\n        return ValidationReport(\n            valid=len(issues) == 0,\n            issues=issues,\n            warnings=warnings,\n            confidence=0.70,\n        )\n\n\ndef _make_lignin_capability() -> MaterialCapability:\n    return MaterialCapability(\n        system_id="functionalized_lignin",\n        physics_class="bulk_sorbent",\n        adapter_class="FunctionalizedLigninAdapter",\n        min_pocket_size_nm=0.0,\n        max_pocket_size_nm=0.0,  # not a cavity system\n        achievable_symmetries=["none"],\n        max_donor_count=1000,  # distributed sites\n        donor_types_available=["O", "N", "S"],\n        positioning_precision_A=5.0,  # bulk average\n        rigidity_range=("flexible", "semi-rigid"),\n        pH_stability=(1.0, 12.0),\n        thermal_stability_K=(273.0, 470.0),\n        solvent_compatibility=["aqueous"],\n        min_practical_scale="g",\n        max_practical_scale="tonne",\n        cost_per_unit_range=(0.50, 25.0),\n        typical_synthesis_time="2–3 days",\n        literature_validation_rate=0.75,\n        literature_examples=500,\n        design_tools_available=[],\n        known_strengths=[\n            "Cheapest backbone ($0.50/kg kraft lignin)",\n            "Renewable (paper industry byproduct)",\n            "HSAB-tunable functionalization (same physics as precision)",\n            "Scalable to tonnes",\n            "High capacity (50–120 mg/g for heavy metals)",\n        ],\n        known_limitations=[\n            "Distributed sites — lower selectivity than defined cavities",\n            "Batch-to-batch variability in lignin properties",\n            "Capacity degrades over regeneration cycles",\n        ],\n    )\n',
    'mabe/realization/tests/test_sprint_r3.py': '"""\nSprint R3 Test Suite — Adapter Registry Integration.\n\nTests:\n    - Adapter registry auto-discovery\n    - Weight profiles (application-aware)\n    - Composite scoring across physics classes\n    - End-to-end ranking: precision vs bulk sorbent\n    - Application context switching\n    - Lignin adapter design pipeline\n    - HSAB routing for bulk materials\n"""\n\nimport pytest\n\nfrom mabe.realization.adapter_registry import (\n    ADAPTER_REGISTRY,\n    AdapterRegistry,\n    register_builtins,\n)\nfrom mabe.realization.adapters.lignin_adapter import (\n    CATION_HSAB,\n    FUNCTIONAL_GROUPS,\n    FunctionalizedLigninAdapter,\n    LigninFabSpec,\n    LIGNIN_BACKBONES,\n    select_functional_group,\n)\nfrom mabe.realization.ranker import (\n    WEIGHT_PROFILES,\n    AdapterRanker,\n    WeightProfile,\n    compute_composite,\n    get_weight_profile,\n)\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    CavityShape,\n    DeviationReport,\n    DonorPosition,\n    InteractionGeometrySpec,\n    RealizationScore,\n    ScaleClass,\n    Solvent,\n)\n\n\n# ─────────────────────────────────────────────\n# Spec fixtures\n# ─────────────────────────────────────────────\n\ndef make_organic_guest_spec() -> InteractionGeometrySpec:\n    """Medium organic guest → β-CD territory."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.SPHERE,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=155.0,\n            aperture_A=6.0,\n            depth_A=7.9,\n            max_internal_diameter_A=6.0,\n        ),\n        symmetry="none",\n        donor_positions=[],\n        pocket_scale_nm=0.60,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_potassium_spec() -> InteractionGeometrySpec:\n    """K⁺ pocket for crown ether."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=11.0,\n            aperture_A=2.76,\n            depth_A=3.0,\n            max_internal_diameter_A=2.76,\n        ),\n        symmetry="C6v",\n        donor_positions=[\n            DonorPosition(\n                atom_type="O", coordination_role="equatorial",\n                position_vector_A=(1.34, 0.0, 0.0),\n                tolerance_A=0.1, required_hybridization="sp3",\n            ),\n        ],\n        pocket_scale_nm=0.28,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_cu2_4N_spec() -> InteractionGeometrySpec:\n    """Cu²⁺ 4N planar → porphyrin territory."""\n    donors = [\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(1.98, 0.0, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(0.0, 1.98, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(-1.98, 0.0, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(0.0, -1.98, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n    ]\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=33.0,\n            aperture_A=3.96,\n            depth_A=3.4,\n            max_internal_diameter_A=3.96,\n        ),\n        symmetry="D4h",\n        donor_positions=donors,\n        pocket_scale_nm=0.40,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_pb2_remediation_spec() -> InteractionGeometrySpec:\n    """Pb²⁺ at remediation scale → bulk sorbent should win."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.SPHERE,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=15.0,\n            aperture_A=2.38,\n            depth_A=3.0,\n            max_internal_diameter_A=2.38,\n        ),\n        symmetry="none",\n        donor_positions=[\n            DonorPosition(\n                atom_type="S", coordination_role="terminal",\n                position_vector_A=(1.19, 0.0, 0.0),\n                tolerance_A=0.5, required_hybridization="any",\n            ),\n        ],\n        pocket_scale_nm=0.24,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.REMEDIATION,\n        required_scale=ScaleClass.MOL,\n    )\n\n\ndef make_soft_metal_spec() -> InteractionGeometrySpec:\n    """Soft metal with S-donors → should trigger thiol/DTC in lignin."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.SPHERE,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=10.0,\n            aperture_A=2.00,\n            depth_A=3.0,\n            max_internal_diameter_A=2.00,\n        ),\n        symmetry="none",\n        donor_positions=[\n            DonorPosition(\n                atom_type="S", coordination_role="terminal",\n                position_vector_A=(1.0, 0.0, 0.0),\n                tolerance_A=0.3, required_hybridization="any",\n            ),\n        ],\n        pocket_scale_nm=0.20,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.REMEDIATION,\n        required_scale=ScaleClass.MOL,\n    )\n\n\ndef make_hard_metal_spec() -> InteractionGeometrySpec:\n    """Hard metal with O-donors → should trigger carboxylate in lignin."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.SPHERE,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=10.0,\n            aperture_A=2.40,\n            depth_A=3.0,\n            max_internal_diameter_A=2.40,\n        ),\n        symmetry="none",\n        donor_positions=[\n            DonorPosition(\n                atom_type="O", coordination_role="terminal",\n                position_vector_A=(1.2, 0.0, 0.0),\n                tolerance_A=0.3, required_hybridization="any",\n            ),\n        ],\n        pocket_scale_nm=0.24,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.REMEDIATION,\n        required_scale=ScaleClass.MOL,\n    )\n\n\n# ─────────────────────────────────────────────\n# Test 1: Adapter Registry\n# ─────────────────────────────────────────────\n\nclass TestAdapterRegistry:\n\n    def test_global_registry_populated(self):\n        assert len(ADAPTER_REGISTRY) >= 4  # CD, crown, porphyrin, lignin\n\n    def test_builtins_registered(self):\n        assert "cyclodextrin" in ADAPTER_REGISTRY\n        assert "crown_ether" in ADAPTER_REGISTRY\n        assert "porphyrin" in ADAPTER_REGISTRY\n        assert "functionalized_lignin" in ADAPTER_REGISTRY\n\n    def test_instantiate_all(self):\n        adapters = ADAPTER_REGISTRY.instantiate_all()\n        assert len(adapters) >= 4\n        # Check registry has all expected keys\n        assert "cyclodextrin" in ADAPTER_REGISTRY\n        assert "functionalized_lignin" in ADAPTER_REGISTRY\n\n    def test_fresh_registry(self):\n        fresh = AdapterRegistry()\n        assert len(fresh) == 0\n        register_builtins(fresh)\n        assert len(fresh) >= 4\n\n    def test_instantiate_returns_same_instance(self):\n        a1 = ADAPTER_REGISTRY.instantiate("cyclodextrin")\n        a2 = ADAPTER_REGISTRY.instantiate("cyclodextrin")\n        assert a1 is a2\n\n    def test_instantiate_unknown_returns_none(self):\n        assert ADAPTER_REGISTRY.instantiate("unobtainium") is None\n\n\n# ─────────────────────────────────────────────\n# Test 2: Weight Profiles\n# ─────────────────────────────────────────────\n\nclass TestWeightProfiles:\n\n    def test_four_profiles_exist(self):\n        assert len(WEIGHT_PROFILES) == 4\n        for name in ("research", "diagnostic", "separation", "remediation"):\n            assert name in WEIGHT_PROFILES\n\n    def test_weights_sum_to_1(self):\n        for name, profile in WEIGHT_PROFILES.items():\n            assert profile.total() == pytest.approx(1.0, abs=0.01), (\n                f"{name} weights sum to {profile.total()}"\n            )\n\n    def test_remediation_weights_capacity_heavily(self):\n        p = WEIGHT_PROFILES["remediation"]\n        assert p.w_capacity > p.w_physics_fidelity\n\n    def test_research_weights_fidelity_heavily(self):\n        p = WEIGHT_PROFILES["research"]\n        assert p.w_physics_fidelity > p.w_capacity\n\n    def test_get_weight_profile_mapping(self):\n        p = get_weight_profile(ApplicationContext.REMEDIATION)\n        assert p.name == "remediation"\n        p = get_weight_profile(ApplicationContext.RESEARCH)\n        assert p.name == "research"\n\n\n# ─────────────────────────────────────────────\n# Test 3: Composite Scoring\n# ─────────────────────────────────────────────\n\nclass TestCompositeScoring:\n\n    def _make_precision_score(self) -> RealizationScore:\n        return RealizationScore(\n            material_system="crown_ether",\n            adapter_id="CrownEtherAdapter",\n            deviation_from_ideal=DeviationReport(\n                "crown_ether", [], 0.1, 0.1,\n            ),\n            physics_fidelity=0.85,\n            synthetic_accessibility=0.80,\n            cost_score=0.70,\n            scalability=0.50,\n            operating_condition_compatibility=0.85,\n            reusability_score=0.40,\n            selectivity_factor=50.0,\n            physics_class="covalent_cavity",\n        )\n\n    def _make_bulk_score(self) -> RealizationScore:\n        return RealizationScore(\n            material_system="functionalized_lignin",\n            adapter_id="FunctionalizedLigninAdapter",\n            deviation_from_ideal=DeviationReport(\n                "functionalized_lignin", [], 1.0, 1.0,\n            ),\n            physics_fidelity=0.35,\n            synthetic_accessibility=0.90,\n            cost_score=0.90,\n            scalability=0.95,\n            operating_condition_compatibility=0.80,\n            reusability_score=0.60,\n            capacity_mmol_per_g=2.5,\n            selectivity_factor=20.0,\n            throughput_L_per_h_per_kg=50.0,\n            regenerability_cycles=15,\n            cost_per_kg_processed=8.0,\n            physics_class="bulk_sorbent",\n        )\n\n    def test_research_prefers_precision(self):\n        weights = WEIGHT_PROFILES["research"]\n        precision = compute_composite(self._make_precision_score(), weights)\n        bulk = compute_composite(self._make_bulk_score(), weights)\n        assert precision > bulk\n\n    def test_remediation_prefers_bulk(self):\n        weights = WEIGHT_PROFILES["remediation"]\n        precision = compute_composite(self._make_precision_score(), weights)\n        bulk = compute_composite(self._make_bulk_score(), weights)\n        assert bulk > precision\n\n    def test_composite_bounded_0_1(self):\n        weights = WEIGHT_PROFILES["research"]\n        score = self._make_precision_score()\n        c = compute_composite(score, weights)\n        assert 0.0 <= c <= 1.0\n\n\n# ─────────────────────────────────────────────\n# Test 4: End-to-End Ranker\n# ─────────────────────────────────────────────\n\nclass TestRankerEndToEnd:\n\n    def setup_method(self):\n        self.adapters = ADAPTER_REGISTRY.instantiate_all()\n        self.ranker = AdapterRanker(self.adapters)\n\n    def test_rank_returns_output(self):\n        spec = make_potassium_spec()\n        result = self.ranker.rank(spec)\n        assert result.recommended_system != "none"\n        assert len(result.all_rankings) >= 4\n\n    def test_organic_guest_prefers_cd(self):\n        """Organic guest + research → CD should rank high."""\n        spec = make_organic_guest_spec()\n        result = self.ranker.rank(spec, ApplicationContext.RESEARCH)\n        # CD should be in top 2\n        top_systems = [r.material_system for r in result.all_rankings[:2]]\n        assert "cyclodextrin" in top_systems\n\n    def test_pb2_remediation_prefers_lignin(self):\n        """Pb²⁺ at remediation scale → lignin should win."""\n        spec = make_pb2_remediation_spec()\n        result = self.ranker.rank(spec, ApplicationContext.REMEDIATION)\n        assert result.recommended_system == "functionalized_lignin"\n\n    def test_pb2_research_prefers_precision(self):\n        """Same Pb²⁺ spec but research → precision binder should win."""\n        spec = make_pb2_remediation_spec()\n        spec.target_application = ApplicationContext.RESEARCH\n        result = self.ranker.rank(spec, ApplicationContext.RESEARCH)\n        assert result.recommended_system != "functionalized_lignin"\n\n    def test_groups_by_physics_class(self):\n        spec = make_pb2_remediation_spec()\n        result = self.ranker.rank(spec)\n        class_names = [g.physics_class for g in result.groups]\n        assert "bulk_sorbent" in class_names\n        assert "covalent_cavity" in class_names\n\n    def test_each_group_has_best(self):\n        spec = make_pb2_remediation_spec()\n        result = self.ranker.rank(spec)\n        for group in result.groups:\n            if group.rankings:\n                assert group.best is not None\n\n    def test_all_scores_have_composite(self):\n        spec = make_potassium_spec()\n        result = self.ranker.rank(spec)\n        for score in result.all_rankings:\n            assert score.composite_score > 0\n\n    def test_rationale_present(self):\n        spec = make_potassium_spec()\n        result = self.ranker.rank(spec)\n        assert len(result.recommendation_rationale) > 0\n\n\n# ─────────────────────────────────────────────\n# Test 5: Lignin HSAB Routing\n# ─────────────────────────────────────────────\n\nclass TestLigninHSABRouting:\n\n    def test_s_donors_select_soft_group(self):\n        """S-donors in spec → dithiocarbamate or thiol."""\n        spec = make_soft_metal_spec()\n        group, rationale = select_functional_group(spec)\n        assert group.hsab_affinity == "soft"\n        assert group.donor_atom == "S"\n\n    def test_o_donors_select_hard_group(self):\n        """O-donors in spec → carboxylate or phosphonate."""\n        spec = make_hard_metal_spec()\n        group, rationale = select_functional_group(spec)\n        assert group.hsab_affinity == "hard"\n        assert group.donor_atom == "O"\n\n    def test_n_donors_select_borderline(self):\n        """N-donors → amine or IDA."""\n        spec = make_cu2_4N_spec()\n        group, rationale = select_functional_group(spec)\n        assert group.hsab_affinity == "borderline"\n        assert group.donor_atom == "N"\n\n\n# ─────────────────────────────────────────────\n# Test 6: Lignin Design Pipeline\n# ─────────────────────────────────────────────\n\nclass TestLigninDesign:\n\n    def setup_method(self):\n        self.adapter = FunctionalizedLigninAdapter()\n\n    def test_returns_lignin_fab_spec(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert isinstance(fab, LigninFabSpec)\n\n    def test_soft_metal_gets_dtc(self):\n        """Pb²⁺ with S-donors → DTC functionalization."""\n        spec = make_soft_metal_spec()\n        fab = self.adapter.design(spec)\n        assert fab.functional_group_abbreviation in ("DTC", "SH")\n        assert fab.donor_subtype == "S_thiolate"\n\n    def test_hard_metal_gets_carboxylate(self):\n        """Hard metal with O-donors → carboxylate."""\n        spec = make_hard_metal_spec()\n        fab = self.adapter.design(spec)\n        assert fab.functional_group_abbreviation in ("COOH", "PO3H2")\n\n    def test_has_synthesis_steps(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.synthesis_steps) >= 4\n\n    def test_has_grafting_chemistry(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.grafting_reagent) > 0\n        assert len(fab.grafting_conditions) > 0\n\n    def test_has_crosslinker(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.crosslinker) > 0\n\n    def test_has_capacity_prediction(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert fab.predicted_qmax_mg_per_g > 0\n        assert fab.predicted_qmax_mmol_per_g > 0\n\n    def test_has_cost_prediction(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert fab.sorbent_cost_per_kg > 0\n        assert fab.predicted_cost_per_kg_removed > 0\n\n    def test_has_validation_plan(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.validation_experiments) >= 3\n        assert any("isotherm" in v for v in fab.validation_experiments)\n\n    def test_backbone_is_kraft(self):\n        """Cheapest backbone should be selected by default."""\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        assert "kraft" in fab.backbone.lower() or "raft" in fab.backbone.lower()\n\n    def test_validation_passes(self):\n        spec = make_pb2_remediation_spec()\n        fab = self.adapter.design(spec)\n        report = self.adapter.validate_design(fab)\n        assert report.valid\n\n\n# ─────────────────────────────────────────────\n# Test 7: Application Context Switching\n# ─────────────────────────────────────────────\n\nclass TestApplicationSwitching:\n    """Same spec, different applications → different winners."""\n\n    def setup_method(self):\n        self.adapters = ADAPTER_REGISTRY.instantiate_all()\n        self.ranker = AdapterRanker(self.adapters)\n\n    def test_remediation_vs_research_different_winner(self):\n        """Pb²⁺ spec: remediation → lignin, research → precision."""\n        spec = make_pb2_remediation_spec()\n\n        result_rem = self.ranker.rank(spec, ApplicationContext.REMEDIATION)\n        result_res = self.ranker.rank(spec, ApplicationContext.RESEARCH)\n\n        assert result_rem.recommended_system == "functionalized_lignin"\n        assert result_res.recommended_system != "functionalized_lignin"\n\n    def test_composite_changes_with_application(self):\n        """Lignin\'s lead over precision changes with application context."""\n        spec = make_pb2_remediation_spec()\n\n        result_rem = self.ranker.rank(spec, ApplicationContext.REMEDIATION)\n        result_res = self.ranker.rank(spec, ApplicationContext.RESEARCH)\n\n        # Get lignin and best precision scores in each context\n        lignin_rem = next(\n            (r for r in result_rem.all_rankings\n             if r.material_system == "functionalized_lignin"), None\n        )\n        lignin_res = next(\n            (r for r in result_res.all_rankings\n             if r.material_system == "functionalized_lignin"), None\n        )\n        best_precision_rem = next(\n            (r for r in result_rem.all_rankings\n             if r.physics_class == "covalent_cavity"), None\n        )\n        best_precision_res = next(\n            (r for r in result_res.all_rankings\n             if r.physics_class == "covalent_cavity"), None\n        )\n\n        assert lignin_rem is not None\n        assert lignin_res is not None\n        assert best_precision_rem is not None\n        assert best_precision_res is not None\n\n        # Lignin\'s lead over precision should be bigger in remediation\n        gap_rem = lignin_rem.composite_score - best_precision_rem.composite_score\n        gap_res = lignin_res.composite_score - best_precision_res.composite_score\n        assert gap_rem > gap_res\n\n\n# ─────────────────────────────────────────────\n# Test 8: Functional Group Knowledge Base\n# ─────────────────────────────────────────────\n\nclass TestFunctionalGroupKnowledge:\n\n    def test_six_groups(self):\n        assert len(FUNCTIONAL_GROUPS) >= 6\n\n    def test_groups_cover_hsab(self):\n        hsab_classes = {g.hsab_affinity for g in FUNCTIONAL_GROUPS.values()}\n        assert "hard" in hsab_classes\n        assert "borderline" in hsab_classes\n        assert "soft" in hsab_classes\n\n    def test_dtc_is_soft(self):\n        assert FUNCTIONAL_GROUPS["dithiocarbamate"].hsab_affinity == "soft"\n\n    def test_carboxylate_is_hard(self):\n        assert FUNCTIONAL_GROUPS["carboxylate"].hsab_affinity == "hard"\n\n    def test_amine_is_borderline(self):\n        assert FUNCTIONAL_GROUPS["amine"].hsab_affinity == "borderline"\n\n    def test_three_backbones(self):\n        assert len(LIGNIN_BACKBONES) >= 3\n\n    def test_kraft_is_practical_default(self):\n        """Kraft lignin is the default backbone (best balance of cost + properties)."""\n        kraft = LIGNIN_BACKBONES["kraft"]\n        assert kraft.phenolic_OH_mmol_per_g > 3.0  # good grafting potential\n        assert kraft.cost_per_kg_usd < 1.00  # cheap\n',
}


def main():
    print("=== MABE Sprint R3: Registry + Ranker + Lignin ===")
    print()

    for filepath, content in FILES.items():
        write_file(filepath, content)
        print(f"  Written {filepath}")

    print()
    print(f"=== Bootstrap complete: {len(FILES)} files ===")
    print()
    print("Run tests:")
    print("  python -m pytest mabe/realization/tests/test_sprint_r3.py -v")
    print("  python -m pytest mabe/realization/tests/ -v  # all 206 tests")


if __name__ == "__main__":
    main()