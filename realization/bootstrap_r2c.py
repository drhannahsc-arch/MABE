"""
MABE Realization Engine — Sprint R2c Bootstrap (Porphyrin Adapter)
Run from your MABE repo root: python realization\bootstrap_r2c.py

Requires: Sprint R1 already installed
Creates:  3 new files in mabe/realization/adapters/ and tests/
Test:     python -m pytest mabe/realization/tests/test_sprint_r2c.py -v
"""

import os
import sys

if not os.path.isfile("mabe/realization/__init__.py"):
    print("ERROR: Sprint R1 not found. Run bootstrap_realization.py first.")
    sys.exit(1)

FILES = {
    'mabe/realization/adapters/porphyrin_knowledge.py': '"""\nPorphyrin & Phthalocyanine Knowledge Base.\n\nMetalloporphyrin properties from CCDC structures and Kadish/Smith/Guilard\nHandbook of Porphyrin Science. Substituent effects from Hammett correlations.\nMetal-N bond distances from crystallographic averages.\n\nData sources:\n    - Kadish KM, Smith KM, Guilard R (2010) Handbook of Porphyrin Science\n    - Fleischer EB (1970) Acc. Chem. Res. — metalloporphyrin structures\n    - Walker FA, Simonis U (2006) Encyclopedia of Inorganic Chemistry\n    - BackSolve Phase 1-5 metal coordination calibration (R²=0.908)\n"""\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nimport math\n\n\n# ─────────────────────────────────────────────\n# Data types\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass PorphyrinCore:\n    """A porphyrin macrocycle variant."""\n\n    name: str\n    abbreviation: str\n    core_type: str                     # "porphyrin", "phthalocyanine", "corrole", "porphyrazine"\n\n    # ── Cavity geometry (crystallographic) ──\n    n_pyrrole_N: int                   # 4 for porphyrin, 4 for Pc, 3 for corrole\n    core_hole_radius_A: float          # center-to-N distance\n    ideal_MN_bond_A: float             # unstrained M-N distance\n    cavity_symmetry: str               # "D4h", "C4v", "C2v"\n\n    # ── Electronics ──\n    base_pKa1: float                   # first protonation of free base\n    base_pKa2: float                   # second protonation\n    electron_richness: str             # "electron-rich", "neutral", "electron-poor"\n\n    # ── Production ──\n    commercial: bool\n    cost_per_gram_usd: float\n    common_suppliers: list[str]\n    synthesis_route: str               # "Lindsey", "Adler-Longo", "Rothemund"\n\n\n@dataclass(frozen=True)\nclass MetalPorphyrinEntry:\n    """Known metal-porphyrin binding data."""\n\n    metal: str\n    charge: int\n    ionic_radius_A: float              # Shannon radius, CN=4 where available\n    preferred_coordination: int        # 4, 5, or 6\n    spin_state: str                    # "low-spin", "high-spin", "diamagnetic"\n\n    # ── Structural data ──\n    typical_MN_bond_A: float           # crystallographic average\n    in_plane: bool                     # True if metal sits in porphyrin plane\n    displacement_A: float              # out-of-plane displacement if not in-plane\n    dome_distortion: bool              # porphyrin ring domes around large metal\n\n    # ── Thermodynamic ──\n    logK_metalation: float             # equilibrium constant for metalation\n    dG_metalation_kJ_mol: float\n    kinetic_class: str                 # "labile", "intermediate", "inert"\n\n    # ── Axial ligand preference ──\n    axial_ligands_typical: list[str]   # common 5th/6th ligands\n    max_axial_count: int               # 0, 1, or 2\n\n    # ── LFSE contribution ──\n    d_electrons: int\n    lfse_kJ_mol: float                 # ligand field stabilization in porph\n\n\n@dataclass(frozen=True)\nclass MesoSubstituent:\n    """Meso-position substituent and its electronic/steric effect."""\n\n    name: str\n    abbreviation: str\n    hammett_sigma: float               # Hammett σ_para — electron effect\n    steric_A_value: float              # A-value (kcal/mol), steric bulk\n    effect_on_metalation: str          # "accelerates", "retards", "neutral"\n    effect_on_redox: str               # "lowers E1/2", "raises E1/2", "neutral"\n    solubility_effect: str             # "hydrophilic", "hydrophobic", "neutral"\n    commercial: bool\n    conjugation_handle: bool           # can attach to scaffold\n\n\n@dataclass(frozen=True)\nclass AxialLigand:\n    """Axial ligand for 5- or 6-coordinate metalloporphyrins."""\n\n    name: str\n    abbreviation: str\n    donor_atom: str                    # "N", "O", "S"\n    donor_subtype: str                 # "N_imine", "N_amine", "O_water", etc.\n    binding_strength: str              # "strong", "moderate", "weak"\n    typical_logK_axial: float          # axial binding constant\n    trans_influence: str               # "strong", "moderate", "weak"\n    labile: bool                       # easily displaced\n\n\n# ─────────────────────────────────────────────\n# Porphyrin cores\n# ─────────────────────────────────────────────\n\nTPP = PorphyrinCore(\n    name="meso-Tetraphenylporphyrin",\n    abbreviation="TPP",\n    core_type="porphyrin",\n    n_pyrrole_N=4,\n    core_hole_radius_A=2.01,\n    ideal_MN_bond_A=2.01,\n    cavity_symmetry="D4h",\n    base_pKa1=4.2,\n    base_pKa2=2.0,\n    electron_richness="neutral",\n    commercial=True,\n    cost_per_gram_usd=5.00,\n    common_suppliers=["Sigma-Aldrich", "TCI", "Frontier Scientific"],\n    synthesis_route="Adler-Longo (pyrrole + benzaldehyde, propionic acid reflux)",\n)\n\nOEP = PorphyrinCore(\n    name="Octaethylporphyrin",\n    abbreviation="OEP",\n    core_type="porphyrin",\n    n_pyrrole_N=4,\n    core_hole_radius_A=2.03,\n    ideal_MN_bond_A=2.03,\n    cavity_symmetry="D4h",\n    base_pKa1=5.0,\n    base_pKa2=3.5,\n    electron_richness="electron-rich",\n    commercial=True,\n    cost_per_gram_usd=15.00,\n    common_suppliers=["Sigma-Aldrich", "Frontier Scientific"],\n    synthesis_route="Fischer (monopyrrole condensation)",\n)\n\nTPFPP = PorphyrinCore(\n    name="meso-Tetrakis(pentafluorophenyl)porphyrin",\n    abbreviation="TPFPP",\n    core_type="porphyrin",\n    n_pyrrole_N=4,\n    core_hole_radius_A=1.99,\n    ideal_MN_bond_A=1.99,\n    cavity_symmetry="D4h",\n    base_pKa1=2.0,\n    base_pKa2=0.5,\n    electron_richness="electron-poor",\n    commercial=True,\n    cost_per_gram_usd=25.00,\n    common_suppliers=["Sigma-Aldrich", "Frontier Scientific"],\n    synthesis_route="Lindsey (BF3·Et2O catalyst, DDQ oxidation)",\n)\n\nTCPP = PorphyrinCore(\n    name="meso-Tetrakis(4-carboxyphenyl)porphyrin",\n    abbreviation="TCPP",\n    core_type="porphyrin",\n    n_pyrrole_N=4,\n    core_hole_radius_A=2.01,\n    ideal_MN_bond_A=2.01,\n    cavity_symmetry="D4h",\n    base_pKa1=4.0,\n    base_pKa2=1.8,\n    electron_richness="neutral",\n    commercial=True,\n    cost_per_gram_usd=20.00,\n    common_suppliers=["Sigma-Aldrich", "TCI", "Frontier Scientific"],\n    synthesis_route="Adler-Longo (pyrrole + 4-carboxybenzaldehyde)",\n)\n\nTAPP = PorphyrinCore(\n    name="meso-Tetrakis(4-aminophenyl)porphyrin",\n    abbreviation="TAPP",\n    core_type="porphyrin",\n    n_pyrrole_N=4,\n    core_hole_radius_A=2.02,\n    ideal_MN_bond_A=2.02,\n    cavity_symmetry="D4h",\n    base_pKa1=5.5,\n    base_pKa2=3.0,\n    electron_richness="electron-rich",\n    commercial=True,\n    cost_per_gram_usd=30.00,\n    common_suppliers=["Sigma-Aldrich", "TCI"],\n    synthesis_route="Adler-Longo then nitro reduction (SnCl2/HCl)",\n)\n\nPC = PorphyrinCore(\n    name="Phthalocyanine",\n    abbreviation="Pc",\n    core_type="phthalocyanine",\n    n_pyrrole_N=4,\n    core_hole_radius_A=1.92,  # slightly smaller cavity than porphyrin\n    ideal_MN_bond_A=1.92,\n    cavity_symmetry="D4h",\n    base_pKa1=3.0,\n    base_pKa2=1.0,\n    electron_richness="electron-rich",\n    commercial=True,\n    cost_per_gram_usd=8.00,\n    common_suppliers=["Sigma-Aldrich", "TCI"],\n    synthesis_route="Phthalonitrile cyclotetramerization (DBU, high-T)",\n)\n\n\nALL_CORES: dict[str, PorphyrinCore] = {\n    "TPP": TPP,\n    "OEP": OEP,\n    "TPFPP": TPFPP,\n    "TCPP": TCPP,\n    "TAPP": TAPP,\n    "Pc": PC,\n}\n\n\n# ─────────────────────────────────────────────\n# Metal-porphyrin database\n# ─────────────────────────────────────────────\n\nMETAL_PORPH_DB: dict[str, MetalPorphyrinEntry] = {\n    "Cu2+": MetalPorphyrinEntry(\n        metal="Cu2+", charge=2, ionic_radius_A=0.57,\n        preferred_coordination=4, spin_state="low-spin",\n        typical_MN_bond_A=1.98, in_plane=True, displacement_A=0.0,\n        dome_distortion=False,\n        logK_metalation=18.0, dG_metalation_kJ_mol=-102.7,\n        kinetic_class="labile",\n        axial_ligands_typical=["pyridine"], max_axial_count=1,\n        d_electrons=9, lfse_kJ_mol=-90.0,\n    ),\n    "Zn2+": MetalPorphyrinEntry(\n        metal="Zn2+", charge=2, ionic_radius_A=0.60,\n        preferred_coordination=5, spin_state="diamagnetic",\n        typical_MN_bond_A=2.04, in_plane=True, displacement_A=0.05,\n        dome_distortion=False,\n        logK_metalation=14.5, dG_metalation_kJ_mol=-82.7,\n        kinetic_class="labile",\n        axial_ligands_typical=["pyridine", "imidazole", "water"],\n        max_axial_count=1,\n        d_electrons=10, lfse_kJ_mol=0.0,\n    ),\n    "Fe2+": MetalPorphyrinEntry(\n        metal="Fe2+", charge=2, ionic_radius_A=0.61,\n        preferred_coordination=6, spin_state="high-spin",\n        typical_MN_bond_A=2.07, in_plane=False, displacement_A=0.30,\n        dome_distortion=True,\n        logK_metalation=12.0, dG_metalation_kJ_mol=-68.5,\n        kinetic_class="intermediate",\n        axial_ligands_typical=["imidazole", "pyridine", "CO", "O2", "NO"],\n        max_axial_count=2,\n        d_electrons=6, lfse_kJ_mol=-50.0,\n    ),\n    "Fe3+": MetalPorphyrinEntry(\n        metal="Fe3+", charge=3, ionic_radius_A=0.55,\n        preferred_coordination=6, spin_state="high-spin",\n        typical_MN_bond_A=2.04, in_plane=True, displacement_A=0.10,\n        dome_distortion=False,\n        logK_metalation=22.0, dG_metalation_kJ_mol=-125.5,\n        kinetic_class="inert",\n        axial_ligands_typical=["Cl-", "OH-", "imidazole", "pyridine"],\n        max_axial_count=2,\n        d_electrons=5, lfse_kJ_mol=0.0,  # d5 HS: zero LFSE\n    ),\n    "Mn2+": MetalPorphyrinEntry(\n        metal="Mn2+", charge=2, ionic_radius_A=0.66,\n        preferred_coordination=6, spin_state="high-spin",\n        typical_MN_bond_A=2.13, in_plane=False, displacement_A=0.25,\n        dome_distortion=True,\n        logK_metalation=8.0, dG_metalation_kJ_mol=-45.6,\n        kinetic_class="labile",\n        axial_ligands_typical=["Cl-", "water", "pyridine"],\n        max_axial_count=2,\n        d_electrons=5, lfse_kJ_mol=0.0,\n    ),\n    "Mn3+": MetalPorphyrinEntry(\n        metal="Mn3+", charge=3, ionic_radius_A=0.58,\n        preferred_coordination=6, spin_state="high-spin",\n        typical_MN_bond_A=2.01, in_plane=True, displacement_A=0.05,\n        dome_distortion=False,\n        logK_metalation=20.0, dG_metalation_kJ_mol=-114.1,\n        kinetic_class="intermediate",\n        axial_ligands_typical=["Cl-", "OAc-", "pyridine"],\n        max_axial_count=2,\n        d_electrons=4, lfse_kJ_mol=-60.0,\n    ),\n    "Co2+": MetalPorphyrinEntry(\n        metal="Co2+", charge=2, ionic_radius_A=0.58,\n        preferred_coordination=5, spin_state="low-spin",\n        typical_MN_bond_A=1.95, in_plane=True, displacement_A=0.0,\n        dome_distortion=False,\n        logK_metalation=16.0, dG_metalation_kJ_mol=-91.3,\n        kinetic_class="intermediate",\n        axial_ligands_typical=["pyridine", "imidazole", "CN-"],\n        max_axial_count=1,\n        d_electrons=7, lfse_kJ_mol=-80.0,\n    ),\n    "Co3+": MetalPorphyrinEntry(\n        metal="Co3+", charge=3, ionic_radius_A=0.55,\n        preferred_coordination=6, spin_state="low-spin",\n        typical_MN_bond_A=1.92, in_plane=True, displacement_A=0.0,\n        dome_distortion=False,\n        logK_metalation=25.0, dG_metalation_kJ_mol=-142.6,\n        kinetic_class="inert",\n        axial_ligands_typical=["CN-", "imidazole", "pyridine"],\n        max_axial_count=2,\n        d_electrons=6, lfse_kJ_mol=-120.0,\n    ),\n    "Ni2+": MetalPorphyrinEntry(\n        metal="Ni2+", charge=2, ionic_radius_A=0.55,\n        preferred_coordination=4, spin_state="low-spin",\n        typical_MN_bond_A=1.93, in_plane=True, displacement_A=0.0,\n        dome_distortion=False,\n        logK_metalation=16.5, dG_metalation_kJ_mol=-94.1,\n        kinetic_class="intermediate",\n        axial_ligands_typical=[], max_axial_count=0,\n        d_electrons=8, lfse_kJ_mol=-100.0,\n    ),\n    "Pd2+": MetalPorphyrinEntry(\n        metal="Pd2+", charge=2, ionic_radius_A=0.64,\n        preferred_coordination=4, spin_state="low-spin",\n        typical_MN_bond_A=2.01, in_plane=True, displacement_A=0.0,\n        dome_distortion=False,\n        logK_metalation=24.0, dG_metalation_kJ_mol=-136.9,\n        kinetic_class="inert",\n        axial_ligands_typical=[], max_axial_count=0,\n        d_electrons=8, lfse_kJ_mol=-150.0,\n    ),\n    "Pb2+": MetalPorphyrinEntry(\n        metal="Pb2+", charge=2, ionic_radius_A=0.98,\n        preferred_coordination=4, spin_state="diamagnetic",\n        typical_MN_bond_A=2.34, in_plane=False, displacement_A=1.00,\n        dome_distortion=True,\n        logK_metalation=6.0, dG_metalation_kJ_mol=-34.2,\n        kinetic_class="labile",\n        axial_ligands_typical=[], max_axial_count=0,\n        d_electrons=0, lfse_kJ_mol=0.0,\n    ),\n    "Mg2+": MetalPorphyrinEntry(\n        metal="Mg2+", charge=2, ionic_radius_A=0.57,\n        preferred_coordination=6, spin_state="diamagnetic",\n        typical_MN_bond_A=2.07, in_plane=True, displacement_A=0.0,\n        dome_distortion=False,\n        logK_metalation=10.0, dG_metalation_kJ_mol=-57.1,\n        kinetic_class="labile",\n        axial_ligands_typical=["water", "pyridine"],\n        max_axial_count=2,\n        d_electrons=0, lfse_kJ_mol=0.0,\n    ),\n}\n\n\n# ─────────────────────────────────────────────\n# Meso-substituent library\n# ─────────────────────────────────────────────\n\nMESO_SUBSTITUENTS: dict[str, MesoSubstituent] = {\n    "phenyl": MesoSubstituent(\n        name="Phenyl", abbreviation="Ph",\n        hammett_sigma=0.0, steric_A_value=3.0,\n        effect_on_metalation="neutral", effect_on_redox="neutral",\n        solubility_effect="hydrophobic",\n        commercial=True, conjugation_handle=False,\n    ),\n    "4-carboxyphenyl": MesoSubstituent(\n        name="4-Carboxyphenyl", abbreviation="4-COOH-Ph",\n        hammett_sigma=0.45, steric_A_value=3.0,\n        effect_on_metalation="retards", effect_on_redox="raises E1/2",\n        solubility_effect="hydrophilic",\n        commercial=True, conjugation_handle=True,\n    ),\n    "4-aminophenyl": MesoSubstituent(\n        name="4-Aminophenyl", abbreviation="4-NH2-Ph",\n        hammett_sigma=-0.66, steric_A_value=3.0,\n        effect_on_metalation="accelerates", effect_on_redox="lowers E1/2",\n        solubility_effect="hydrophilic",\n        commercial=True, conjugation_handle=True,\n    ),\n    "pentafluorophenyl": MesoSubstituent(\n        name="Pentafluorophenyl", abbreviation="C6F5",\n        hammett_sigma=0.27, steric_A_value=3.5,\n        effect_on_metalation="retards", effect_on_redox="raises E1/2",\n        solubility_effect="hydrophobic",\n        commercial=True, conjugation_handle=False,\n    ),\n    "4-pyridyl": MesoSubstituent(\n        name="4-Pyridyl", abbreviation="4-Py",\n        hammett_sigma=0.44, steric_A_value=2.8,\n        effect_on_metalation="retards", effect_on_redox="raises E1/2",\n        solubility_effect="hydrophilic",\n        commercial=True, conjugation_handle=True,\n    ),\n    "mesityl": MesoSubstituent(\n        name="Mesityl (2,4,6-trimethylphenyl)", abbreviation="Mes",\n        hammett_sigma=-0.07, steric_A_value=5.0,\n        effect_on_metalation="neutral", effect_on_redox="neutral",\n        solubility_effect="hydrophobic",\n        commercial=True, conjugation_handle=False,\n    ),\n    "4-hydroxyphenyl": MesoSubstituent(\n        name="4-Hydroxyphenyl", abbreviation="4-OH-Ph",\n        hammett_sigma=-0.37, steric_A_value=3.0,\n        effect_on_metalation="accelerates", effect_on_redox="lowers E1/2",\n        solubility_effect="hydrophilic",\n        commercial=True, conjugation_handle=True,\n    ),\n}\n\n\n# ─────────────────────────────────────────────\n# Axial ligand library\n# ─────────────────────────────────────────────\n\nAXIAL_LIGANDS: dict[str, AxialLigand] = {\n    "imidazole": AxialLigand(\n        name="Imidazole", abbreviation="Im",\n        donor_atom="N", donor_subtype="N_imine",\n        binding_strength="strong", typical_logK_axial=3.5,\n        trans_influence="moderate", labile=False,\n    ),\n    "pyridine": AxialLigand(\n        name="Pyridine", abbreviation="Py",\n        donor_atom="N", donor_subtype="N_imine",\n        binding_strength="moderate", typical_logK_axial=2.8,\n        trans_influence="moderate", labile=True,\n    ),\n    "chloride": AxialLigand(\n        name="Chloride", abbreviation="Cl-",\n        donor_atom="Cl", donor_subtype="halide",\n        binding_strength="moderate", typical_logK_axial=2.5,\n        trans_influence="weak", labile=True,\n    ),\n    "hydroxide": AxialLigand(\n        name="Hydroxide", abbreviation="OH-",\n        donor_atom="O", donor_subtype="O_hydroxide",\n        binding_strength="moderate", typical_logK_axial=3.0,\n        trans_influence="moderate", labile=True,\n    ),\n    "water": AxialLigand(\n        name="Water", abbreviation="H2O",\n        donor_atom="O", donor_subtype="O_water",\n        binding_strength="weak", typical_logK_axial=0.5,\n        trans_influence="weak", labile=True,\n    ),\n    "cyanide": AxialLigand(\n        name="Cyanide", abbreviation="CN-",\n        donor_atom="C", donor_subtype="C_cyanide",\n        binding_strength="strong", typical_logK_axial=5.0,\n        trans_influence="strong", labile=False,\n    ),\n    "CO": AxialLigand(\n        name="Carbon monoxide", abbreviation="CO",\n        donor_atom="C", donor_subtype="C_carbonyl",\n        binding_strength="strong", typical_logK_axial=4.5,\n        trans_influence="strong", labile=False,\n    ),\n    "thiolate": AxialLigand(\n        name="Thiolate", abbreviation="RS-",\n        donor_atom="S", donor_subtype="S_thiolate",\n        binding_strength="strong", typical_logK_axial=4.0,\n        trans_influence="strong", labile=False,\n    ),\n}\n\n\n# ─────────────────────────────────────────────\n# BackSolve calibrated parameters for metal-porphyrin\n# ─────────────────────────────────────────────\n\nBACKSOLVE_METAL_PARAMS = {\n    # From Phase 1-5 joint calibration (R²=0.908, MAE=2.35)\n    "N_pyrrole_exchange_kJ_mol": -45.0,    # per M-N_pyrrole bond\n    "lfse_scale": 0.85,                     # scaling of free-ion LFSE\n    "macrocyclic_stab_per_N": 3.5,          # kJ/mol per donor (preorganization)\n    "size_match_sigma_A": 0.15,             # Gaussian width for M-N match\n    "size_match_penalty_kJ": 25.0,          # max penalty for mismatch\n    "axial_base_kJ": -15.0,                # per axial ligand\n    "hammett_rho": 8.0,                    # ρ for metalation ΔG (kJ/mol per σ): +σ → +ΔG (less favorable)\n}\n\n\n# ─────────────────────────────────────────────\n# Physics functions\n# ─────────────────────────────────────────────\n\ndef metal_porphyrin_size_match(\n    metal_ionic_radius_A: float,\n    core_hole_radius_A: float,\n) -> float:\n    """\n    Size-match score for metal in porphyrin core hole.\n\n    Porphyrin core hole is ~2.01 Å (center-to-N).\n    Ideal M-N bond ≈ core_hole_radius.\n    Returns 0.0–1.0.\n    """\n    sigma = BACKSOLVE_METAL_PARAMS["size_match_sigma_A"]\n    # Compare M-N bond (≈ ionic_radius + ~1.40 Å for N) to core hole\n    # Simplified: direct comparison of ionic radius to ideal\n    ideal_radius = core_hole_radius_A - 1.40  # N covalent radius ~1.40 for M-N\n    delta = metal_ionic_radius_A - ideal_radius\n    return math.exp(-0.5 * (delta / sigma) ** 2)\n\n\ndef predict_metalation_dG(\n    metal: MetalPorphyrinEntry,\n    core: PorphyrinCore,\n    meso_sigma: float = 0.0,\n    n_axial: int = 0,\n) -> float:\n    """\n    Predict metalation ΔG from BackSolve parameters.\n\n    Terms:\n        1. M-N exchange (4 bonds × per-bond energy)\n        2. LFSE contribution (scaled)\n        3. Macrocyclic stabilization\n        4. Size-match penalty\n        5. Substituent effect (Hammett)\n        6. Axial ligand stabilization\n    """\n    params = BACKSOLVE_METAL_PARAMS\n\n    # M-N exchange\n    dG_exchange = core.n_pyrrole_N * params["N_pyrrole_exchange_kJ_mol"]\n\n    # LFSE\n    dG_lfse = metal.lfse_kJ_mol * params["lfse_scale"]\n\n    # Macrocyclic\n    dG_macro = -core.n_pyrrole_N * params["macrocyclic_stab_per_N"]\n\n    # Size match penalty\n    sm = metal_porphyrin_size_match(metal.ionic_radius_A, core.core_hole_radius_A)\n    dG_size = params["size_match_penalty_kJ"] * (1.0 - sm)\n\n    # Hammett substituent effect\n    dG_hammett = params["hammett_rho"] * meso_sigma\n\n    # Axial\n    dG_axial = n_axial * params["axial_base_kJ"]\n\n    return dG_exchange + dG_lfse + dG_macro + dG_size + dG_hammett + dG_axial\n\n\ndef select_core_for_metal(metal_symbol: str) -> list[tuple[PorphyrinCore, float, str]]:\n    """\n    Rank porphyrin cores for a target metal.\n\n    Returns (core, size_match_score, rationale) sorted by suitability.\n    """\n    if metal_symbol not in METAL_PORPH_DB:\n        return []\n\n    metal = METAL_PORPH_DB[metal_symbol]\n    results = []\n\n    for core in ALL_CORES.values():\n        sm = metal_porphyrin_size_match(metal.ionic_radius_A, core.core_hole_radius_A)\n\n        parts = [f"size-match={sm:.2f}"]\n\n        # Electron-poor cores stabilize electron-rich metals (high d-count)\n        if metal.d_electrons >= 8 and core.electron_richness == "electron-poor":\n            parts.append("electron-poor core matches d8+ metal")\n        if metal.d_electrons <= 4 and core.electron_richness == "electron-rich":\n            parts.append("electron-rich core stabilizes low-d metal")\n\n        # Phthalocyanine has smaller hole — better for small metals\n        if core.core_type == "phthalocyanine" and metal.ionic_radius_A < 0.58:\n            parts.append("Pc smaller cavity suits small ion")\n\n        results.append((core, sm, "; ".join(parts)))\n\n    results.sort(key=lambda x: x[1], reverse=True)\n    return results\n',
    'mabe/realization/adapters/porphyrin_adapter.py': '"""\nPorphyrin / Phthalocyanine Adapter — Layer 4 Implementation.\n\nTakes an InteractionGeometrySpec describing a planar 4N coordination pocket\nand designs a metalloporphyrin realization.\n\nDesign logic:\n    1. Identify target metal from spec (4N planar, ionic radius)\n    2. Select porphyrin core (TPP, OEP, TPFPP, Pc, etc.)\n    3. Choose meso-substituents for electronics + conjugation\n    4. Add axial ligands if spec requires 5th/6th coordination\n    5. Produce PorphyrinFabSpec with full design + synthesis route\n\nPhysics connection:\n    - M-N bond distance → BackSolve metal coordination (R²=0.908)\n    - LFSE → d-electron configuration\n    - Size-match → core hole radius vs ionic radius\n    - Hammett σ → substituent electronic tuning\n"""\n\nfrom __future__ import annotations\n\nimport hashlib\nimport math\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mabe.realization.adapters.base import RealizationAdapter, ValidationReport\nfrom mabe.realization.adapters.porphyrin_knowledge import (\n    ALL_CORES,\n    AXIAL_LIGANDS,\n    BACKSOLVE_METAL_PARAMS,\n    MESO_SUBSTITUENTS,\n    METAL_PORPH_DB,\n    AxialLigand,\n    MesoSubstituent,\n    MetalPorphyrinEntry,\n    PorphyrinCore,\n    metal_porphyrin_size_match,\n    predict_metalation_dG,\n    select_core_for_metal,\n)\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    CavityShape,\n    DeviationReport,\n    FabricationSpec,\n    InteractionGeometrySpec,\n    RealizationScore,\n    Solvent,\n)\nfrom mabe.realization.registry.material_registry import MaterialCapability\n\n\n# ─────────────────────────────────────────────\n# PorphyrinFabSpec\n# ─────────────────────────────────────────────\n\n@dataclass\nclass PorphyrinFabSpec(FabricationSpec):\n    """Fabrication spec for a metalloporphyrin pocket."""\n\n    # ── Core selection ──\n    selected_core: str = ""\n    core_abbreviation: str = ""\n    core_type: str = ""\n    core_hole_radius_A: float = 0.0\n\n    # ── Metal ──\n    target_metal: str = ""\n    metal_ionic_radius_A: float = 0.0\n    metal_coordination: int = 0\n    metal_spin_state: str = ""\n\n    # ── Size match ──\n    size_match_score: float = 0.0\n    mn_bond_predicted_A: float = 0.0\n    in_plane: bool = True\n\n    # ── Substituents ──\n    meso_substituent: str = ""\n    meso_rationale: str = ""\n    hammett_sigma_sum: float = 0.0\n\n    # ── Axial ligands ──\n    axial_ligands: list[str] = field(default_factory=list)\n    axial_rationale: str = ""\n\n    # ── Binding prediction ──\n    predicted_dG_metalation_kJ_mol: float = 0.0\n    predicted_logK_metalation: float = 0.0\n    kinetic_class: str = ""\n\n    # ── Synthesis ──\n    synthesis_route: str = ""\n    metalation_protocol: str = ""\n\n    # ── Sourcing ──\n    supplier: str = ""\n    catalog_note: str = ""\n\n\n# ─────────────────────────────────────────────\n# Adapter\n# ─────────────────────────────────────────────\n\nclass PorphyrinAdapter(RealizationAdapter):\n    """\n    Designs metalloporphyrin binding pockets.\n\n    Class A (Covalent Cavity / Planar Coordination Ring):\n        - 4N planar pocket, D4h symmetry\n        - Core hole ~2.01 Å (porphyrin) or ~1.92 Å (Pc)\n        - Design freedom: meso-substituents, axial ligands, core type\n        - Highest positioning precision (0.01 Å)\n        - Limited to metals that fit the ~2 Å core hole\n    """\n\n    def __init__(self, capability: Optional[MaterialCapability] = None):\n        if capability is None:\n            from mabe.realization.registry.material_registry import MATERIAL_REGISTRY\n            capability = MATERIAL_REGISTRY.get("planar_coordination_ring")\n            if capability is None:\n                capability = _make_porph_capability()\n        super().__init__(capability)\n\n    def estimate_fidelity(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> RealizationScore:\n        """\n        Quick score: does this spec match a 4N planar coordination pocket?\n        """\n\n        metal_symbol = self._identify_target_metal(spec)\n        metal = METAL_PORPH_DB.get(metal_symbol)\n\n        if metal is None:\n            return self._infeasible_score(\n                f"Metal {metal_symbol} not in porphyrin database"\n            )\n\n        # ── Size match across all cores ──\n        ranked = select_core_for_metal(metal_symbol)\n        if not ranked:\n            return self._infeasible_score("No suitable core")\n\n        best_core, sm, _rationale = ranked[0]\n\n        # ── Physics fidelity ──\n        physics_fidelity = sm * 0.5\n\n        # Geometry match: spec must be planar 4N\n        n_N_donors = sum(\n            1 for d in spec.donor_positions if d.atom_type == "N"\n        )\n        if n_N_donors >= 4:\n            physics_fidelity += 0.3\n        elif n_N_donors >= 2:\n            physics_fidelity += 0.1\n\n        # Symmetry bonus\n        if spec.cavity_shape == CavityShape.FLAT:\n            physics_fidelity += 0.15\n        elif spec.cavity_shape == CavityShape.SPHERE:\n            physics_fidelity += 0.05\n\n        physics_fidelity = max(0.0, min(1.0, physics_fidelity))\n\n        # ── Deviation ──\n        mn_dev = abs(metal.typical_MN_bond_A - best_core.ideal_MN_bond_A)\n        deviation = DeviationReport(\n            material_system="porphyrin",\n            element_deviations_A=[mn_dev] * 4,\n            max_deviation_A=mn_dev,\n            mean_deviation_A=mn_dev,\n        )\n\n        # ── Advantages / limitations ──\n        advantages = []\n        limitations = []\n\n        advantages.append(f"Highest positioning precision (0.01 Å)")\n        if best_core.commercial:\n            advantages.append(\n                f"{best_core.abbreviation} commercial "\n                f"(${best_core.cost_per_gram_usd}/g)"\n            )\n        if metal.logK_metalation > 15:\n            advantages.append(\n                f"Strong metalation (logK={metal.logK_metalation:.0f})"\n            )\n        if sm > 0.8:\n            advantages.append("Excellent metal-cavity size match")\n\n        if not metal.in_plane:\n            limitations.append(\n                f"{metal.metal} sits {metal.displacement_A:.2f} Å out-of-plane"\n            )\n        if metal.kinetic_class == "labile":\n            limitations.append("Labile metalation — demetalation risk in acid")\n        if metal.ionic_radius_A > 0.80:\n            limitations.append("Large ion — significant ring distortion expected")\n\n        return RealizationScore(\n            material_system="porphyrin",\n            adapter_id="PorphyrinAdapter",\n            deviation_from_ideal=deviation,\n            physics_fidelity=physics_fidelity,\n            synthetic_accessibility=0.80,\n            cost_score=0.70,\n            scalability=0.80,\n            operating_condition_compatibility=0.85,\n            reusability_score=0.7,\n            composite_score=0.0,\n            confidence=0.85,\n            advantages=advantages,\n            limitations=limitations,\n            feasible=True,\n        )\n\n    def design(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> PorphyrinFabSpec:\n        """\n        Full metalloporphyrin design.\n\n        1. Identify target metal\n        2. Select porphyrin core by size match\n        3. Choose meso-substituent (electronics + function)\n        4. Add axial ligands if needed\n        5. Predict metalation affinity\n        """\n\n        spec_hash = hashlib.md5(str(spec).encode()).hexdigest()[:12]\n        metal_symbol = self._identify_target_metal(spec)\n        metal = METAL_PORPH_DB.get(metal_symbol)\n\n        if metal is None:\n            return self._empty_fab(spec_hash, f"Metal {metal_symbol} unknown")\n\n        # ── Step 1: Core selection ──\n        ranked = select_core_for_metal(metal_symbol)\n        if not ranked:\n            return self._empty_fab(spec_hash, "No suitable core")\n\n        best_core, sm, _core_rationale = ranked[0]\n\n        # ── Step 2: Meso-substituent selection ──\n        meso, meso_rationale = self._select_meso(metal, spec)\n\n        # ── Step 3: Axial ligand selection ──\n        axial_list, axial_rationale = self._select_axial(metal, spec)\n\n        # ── Step 4: Predict metalation ──\n        hammett_sum = meso.hammett_sigma * 4  # 4 meso positions\n        dG_met = predict_metalation_dG(\n            metal, best_core,\n            meso_sigma=hammett_sum,\n            n_axial=len(axial_list),\n        )\n        RT = 8.314e-3 * 298.15\n        logK_met = -dG_met / (2.303 * RT)\n\n        # ── Step 5: Synthesis route ──\n        steps = [\n            f"Synthesize {best_core.abbreviation} via {best_core.synthesis_route}",\n        ]\n        if best_core.commercial:\n            steps[0] = f"Procure {best_core.abbreviation} from {best_core.common_suppliers[0]}"\n\n        # Metalation protocol\n        if metal.kinetic_class == "labile":\n            metalation = (\n                f"Dissolve {best_core.abbreviation} in DMF, add {metal.metal} "\n                f"acetate (5 eq), stir 60°C, 2h. Monitor by UV-vis (Soret shift)."\n            )\n        elif metal.kinetic_class == "intermediate":\n            metalation = (\n                f"Reflux {best_core.abbreviation} with {metal.metal} chloride "\n                f"(10 eq) in DMF, 4-12h. Column purification (silica, CHCl3)."\n            )\n        else:  # inert\n            metalation = (\n                f"Reflux {best_core.abbreviation} with {metal.metal} salt "\n                f"in glacial AcOH, 12-24h. Extended reaction time for inert metal."\n            )\n\n        steps.append(metalation)\n        steps.append(\n            "Purify: column chromatography (silica gel, CHCl3/MeOH)"\n        )\n        steps.append(\n            "Characterize: UV-vis (Soret + Q bands), MALDI-TOF, 1H NMR"\n        )\n\n        if axial_list:\n            axial_names = ", ".join(a.name for a in axial_list)\n            steps.append(\n                f"Axial coordination: add {axial_names} "\n                f"(stoichiometric) in solution"\n            )\n\n        # ── Step 6: Validation plan ──\n        validation = [\n            f"UV-vis: Soret band shift confirms metalation ({metal.metal})",\n            "MALDI-TOF: confirm M-porphyrin MW",\n        ]\n        if axial_list:\n            validation.append(\n                "EPR/NMR: confirm axial coordination geometry"\n            )\n        if spec.target_application in (\n            ApplicationContext.DIAGNOSTIC,\n            ApplicationContext.SEPARATION,\n        ):\n            validation.append(\n                f"ITC: binding affinity for {metal.metal} in target matrix"\n            )\n\n        expected = {\n            "logK_metalation": logK_met,\n            "dG_kJ_mol": dG_met,\n            "soret_band_nm": 420 if best_core.core_type == "porphyrin" else 680,\n            "coordination_number": metal.preferred_coordination,\n            "spin_state": metal.spin_state,\n        }\n\n        return PorphyrinFabSpec(\n            material_system="porphyrin",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(\n                volume_A3=4/3 * math.pi * best_core.core_hole_radius_A ** 3,\n                aperture_A=best_core.core_hole_radius_A * 2,\n                depth_A=3.4 if not axial_list else 6.0,\n                max_internal_diameter_A=best_core.core_hole_radius_A * 2,\n            ),\n            predicted_deviation_from_ideal_A=abs(\n                metal.typical_MN_bond_A - best_core.ideal_MN_bond_A\n            ),\n            synthesis_steps=steps,\n            estimated_yield=0.60 if metal.kinetic_class == "labile" else 0.40,\n            estimated_cost_per_unit=best_core.cost_per_gram_usd * 2.0,\n            estimated_time="1 day" if metal.kinetic_class == "labile" else "2–3 days",\n            validation_experiments=validation,\n            expected_observables=expected,\n            # Porphyrin-specific\n            selected_core=best_core.name,\n            core_abbreviation=best_core.abbreviation,\n            core_type=best_core.core_type,\n            core_hole_radius_A=best_core.core_hole_radius_A,\n            target_metal=metal.metal,\n            metal_ionic_radius_A=metal.ionic_radius_A,\n            metal_coordination=metal.preferred_coordination,\n            metal_spin_state=metal.spin_state,\n            size_match_score=sm,\n            mn_bond_predicted_A=metal.typical_MN_bond_A,\n            in_plane=metal.in_plane,\n            meso_substituent=meso.abbreviation,\n            meso_rationale=meso_rationale,\n            hammett_sigma_sum=hammett_sum,\n            axial_ligands=[a.abbreviation for a in axial_list],\n            axial_rationale=axial_rationale,\n            predicted_dG_metalation_kJ_mol=dG_met,\n            predicted_logK_metalation=logK_met,\n            kinetic_class=metal.kinetic_class,\n            synthesis_route=best_core.synthesis_route,\n            metalation_protocol=metalation,\n            supplier=(\n                best_core.common_suppliers[0] if best_core.commercial\n                else "custom synthesis"\n            ),\n            catalog_note=f"{best_core.abbreviation}, {best_core.cost_per_gram_usd}$/g",\n        )\n\n    def validate_design(self, fab: FabricationSpec) -> ValidationReport:\n        """Check porphyrin design for internal consistency."""\n\n        if not isinstance(fab, PorphyrinFabSpec):\n            return ValidationReport(\n                valid=False,\n                issues=["Not a PorphyrinFabSpec"],\n                warnings=[],\n            )\n\n        issues = []\n        warnings = []\n\n        # Size match\n        if fab.size_match_score < 0.3:\n            issues.append(\n                f"Size match {fab.size_match_score:.2f} too poor — "\n                "severe ring distortion expected"\n            )\n\n        # Out-of-plane displacement\n        if not fab.in_plane:\n            warnings.append(\n                f"{fab.target_metal} sits out-of-plane — "\n                "may affect selectivity"\n            )\n\n        # Axial count vs metal preference\n        metal = METAL_PORPH_DB.get(fab.target_metal)\n        if metal and len(fab.axial_ligands) > metal.max_axial_count:\n            issues.append(\n                f"{fab.target_metal} max axial={metal.max_axial_count}, "\n                f"but {len(fab.axial_ligands)} specified"\n            )\n\n        # Labile metalation warning\n        if fab.kinetic_class == "labile":\n            warnings.append(\n                "Labile metalation: risk of demetalation below pH 3"\n            )\n\n        return ValidationReport(\n            valid=len(issues) == 0,\n            issues=issues,\n            warnings=warnings,\n            confidence=0.85,\n        )\n\n    # ─────────────────────────────────────────\n    # Internal\n    # ─────────────────────────────────────────\n\n    def _identify_target_metal(self, spec: InteractionGeometrySpec) -> str:\n        """\n        Identify target metal from spec.\n\n        Strategy:\n            1. Match cavity size to known M-N bond distances\n            2. Disambiguate by coordination number (count of donor positions)\n        """\n        spec_radius = spec.cavity_dimensions.max_internal_diameter_A / 2.0\n        spec_coord = len(spec.donor_positions)\n\n        best_match = "Cu2+"\n        best_score = float("inf")\n\n        for symbol, metal in METAL_PORPH_DB.items():\n            # Distance penalty\n            delta = abs(metal.typical_MN_bond_A - spec_radius)\n            # Coordination mismatch penalty\n            coord_penalty = abs(metal.preferred_coordination - spec_coord) * 0.1\n            score = delta + coord_penalty\n            if score < best_score:\n                best_score = score\n                best_match = symbol\n\n        return best_match\n\n    def _select_meso(\n        self,\n        metal: MetalPorphyrinEntry,\n        spec: InteractionGeometrySpec,\n    ) -> tuple[MesoSubstituent, str]:\n        """Select meso-substituent based on metal electronics + application."""\n\n        # Default to phenyl\n        selected = MESO_SUBSTITUENTS["phenyl"]\n        rationale = "Standard TPP — well-characterized, commercial"\n\n        # Application-driven conjugation handle\n        if spec.target_application in (\n            ApplicationContext.DIAGNOSTIC,\n            ApplicationContext.SEPARATION,\n        ):\n            selected = MESO_SUBSTITUENTS["4-carboxyphenyl"]\n            rationale = (\n                "4-COOH-Ph: conjugation handle for scaffold attachment "\n                "(EDC/NHS coupling). Water-soluble."\n            )\n            return selected, rationale\n\n        # Electronic tuning for electron-rich metals (d8+)\n        if metal.d_electrons >= 8:\n            selected = MESO_SUBSTITUENTS["pentafluorophenyl"]\n            rationale = (\n                f"C6F5: electron-poor meso for d{metal.d_electrons} metal. "\n                "Stabilizes electron-rich center, raises redox potential."\n            )\n            return selected, rationale\n\n        # Electron-rich core for early/low-d metals\n        if metal.d_electrons <= 4 and metal.charge >= 3:\n            selected = MESO_SUBSTITUENTS["4-aminophenyl"]\n            rationale = (\n                f"4-NH2-Ph: electron-rich meso for high-charge M{metal.charge}+. "\n                "Accelerates metalation, lowers redox potential."\n            )\n            return selected, rationale\n\n        return selected, rationale\n\n    def _select_axial(\n        self,\n        metal: MetalPorphyrinEntry,\n        spec: InteractionGeometrySpec,\n    ) -> tuple[list[AxialLigand], str]:\n        """Select axial ligands based on metal coordination preference."""\n\n        if metal.max_axial_count == 0:\n            return [], "4-coordinate metal — no axial ligands needed"\n\n        # Check if spec has axial donor positions\n        axial_donors = [\n            d for d in spec.donor_positions\n            if d.coordination_role == "axial"\n        ]\n\n        if not axial_donors and metal.preferred_coordination <= 4:\n            return [], "Spec does not require axial coordination"\n\n        # Select based on metal preference\n        n_axial = min(\n            metal.max_axial_count,\n            max(1, metal.preferred_coordination - 4),\n        )\n\n        # Pick best axial ligand for this metal\n        ligand_scores = []\n        for lig in AXIAL_LIGANDS.values():\n            score = lig.typical_logK_axial\n            # Bonus for matching metal\'s typical axial ligands\n            if lig.abbreviation in metal.axial_ligands_typical:\n                score += 2.0\n            # Aqueous penalty for non-labile if in water\n            ligand_scores.append((lig, score))\n\n        ligand_scores.sort(key=lambda x: x[1], reverse=True)\n        selected = [ligand_scores[0][0]] * n_axial\n\n        lig_names = ", ".join(l.abbreviation for l in selected)\n        rationale = (\n            f"{metal.metal} prefers {metal.preferred_coordination}-coordinate: "\n            f"{n_axial} axial {lig_names} selected "\n            f"(logK_axial={selected[0].typical_logK_axial:.1f})"\n        )\n\n        return selected, rationale\n\n    def _infeasible_score(self, reason: str) -> RealizationScore:\n        return RealizationScore(\n            material_system="porphyrin",\n            adapter_id="PorphyrinAdapter",\n            deviation_from_ideal=DeviationReport(\n                material_system="porphyrin",\n                element_deviations_A=[],\n                max_deviation_A=float("inf"),\n                mean_deviation_A=float("inf"),\n            ),\n            physics_fidelity=0.0,\n            feasible=False,\n            infeasibility_reason=reason,\n        )\n\n    def _empty_fab(self, spec_hash: str, reason: str) -> PorphyrinFabSpec:\n        return PorphyrinFabSpec(\n            material_system="porphyrin",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(0, 0, 0, 0),\n            predicted_deviation_from_ideal_A=float("inf"),\n            synthesis_steps=[f"DESIGN FAILED: {reason}"],\n        )\n\n\ndef _make_porph_capability() -> MaterialCapability:\n    return MaterialCapability(\n        system_id="porphyrin",\n        physics_class="covalent_cavity",\n        adapter_class="PorphyrinAdapter",\n        min_pocket_size_nm=0.38,\n        max_pocket_size_nm=0.41,\n        achievable_symmetries=["D4h", "C4v", "C2v"],\n        max_donor_count=6,\n        donor_types_available=["N"],\n        positioning_precision_A=0.01,\n        rigidity_range=("rigid", "rigid"),\n        pH_stability=(1.0, 14.0),\n        thermal_stability_K=(273.0, 600.0),\n        solvent_compatibility=["aqueous", "organic", "mixed"],\n        min_practical_scale="µmol",\n        max_practical_scale="mol",\n        cost_per_unit_range=(5.0, 50.0),\n        typical_synthesis_time="1–3 days",\n        literature_validation_rate=0.85,\n        literature_examples=50000,\n        design_tools_available=["RDKit"],\n        known_strengths=[\n            "Highest precision covalent cavity (0.01 Å)",\n            "BackSolve-calibrated (R²=0.908)",\n            "Rigid D4h geometry — highly preorganized",\n            "Vast literature + commercial availability",\n        ],\n        known_limitations=[\n            "4N planar only — single geometry class",\n            "Large metals (Pb2+) cause severe distortion",\n            "Selectivity via cavity size is limited (fixed ~2 Å hole)",\n        ],\n    )\n',
    'mabe/realization/tests/test_sprint_r2c.py': '"""\nSprint R2c Test Suite — Porphyrin Adapter.\n\nTests:\n    - Knowledge base integrity (cores, metals, substituents, axial ligands)\n    - Metal identification from spec\n    - Core selection (size-match physics)\n    - Meso-substituent selection (Hammett, application-driven)\n    - Axial ligand selection (coordination number driven)\n    - Full design pipeline (spec → PorphyrinFabSpec)\n    - Validation checks\n"""\n\nimport math\nimport pytest\n\nfrom mabe.realization.adapters.porphyrin_adapter import (\n    PorphyrinAdapter,\n    PorphyrinFabSpec,\n)\nfrom mabe.realization.adapters.porphyrin_knowledge import (\n    ALL_CORES,\n    AXIAL_LIGANDS,\n    BACKSOLVE_METAL_PARAMS,\n    MESO_SUBSTITUENTS,\n    METAL_PORPH_DB,\n    OEP,\n    PC,\n    TPFPP,\n    TPP,\n    metal_porphyrin_size_match,\n    predict_metalation_dG,\n    select_core_for_metal,\n)\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    CavityShape,\n    DonorPosition,\n    InteractionGeometrySpec,\n    ScaleClass,\n    Solvent,\n)\n\n\n# ─────────────────────────────────────────────\n# Spec fixtures — 4N planar pockets\n# ─────────────────────────────────────────────\n\ndef _make_4N_donor_positions(bond_A: float = 2.00) -> list[DonorPosition]:\n    """4 N donors in square planar arrangement."""\n    return [\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(bond_A, 0.0, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(0.0, bond_A, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(-bond_A, 0.0, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n        DonorPosition(\n            atom_type="N", coordination_role="equatorial",\n            position_vector_A=(0.0, -bond_A, 0.0),\n            tolerance_A=0.05, required_hybridization="sp2",\n        ),\n    ]\n\n\ndef make_cu2_spec() -> InteractionGeometrySpec:\n    """Cu²⁺: 4-coordinate, in-plane, M-N ~1.98 Å → diameter ~3.96."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=33.0,\n            aperture_A=3.96,\n            depth_A=3.4,\n            max_internal_diameter_A=3.96,\n        ),\n        symmetry="D4h",\n        donor_positions=_make_4N_donor_positions(1.98),\n        pocket_scale_nm=0.40,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_fe3_spec() -> InteractionGeometrySpec:\n    """Fe³⁺: 6-coordinate, needs axial ligands, M-N ~2.04 Å."""\n    donors = _make_4N_donor_positions(2.04)\n    # Add 2 axial positions\n    donors.append(DonorPosition(\n        atom_type="N", coordination_role="axial",\n        position_vector_A=(0.0, 0.0, 2.10),\n        tolerance_A=0.1, required_hybridization="sp2",\n    ))\n    donors.append(DonorPosition(\n        atom_type="N", coordination_role="axial",\n        position_vector_A=(0.0, 0.0, -2.10),\n        tolerance_A=0.1, required_hybridization="sp2",\n    ))\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=35.0,\n            aperture_A=4.08,\n            depth_A=6.0,\n            max_internal_diameter_A=4.08,\n        ),\n        symmetry="D4h",\n        donor_positions=donors,\n        pocket_scale_nm=0.40,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_zn2_spec() -> InteractionGeometrySpec:\n    """Zn²⁺: 5-coordinate, one axial, M-N ~2.04 Å."""\n    donors = _make_4N_donor_positions(2.04)\n    donors.append(DonorPosition(\n        atom_type="N", coordination_role="axial",\n        position_vector_A=(0.0, 0.0, 2.15),\n        tolerance_A=0.1, required_hybridization="sp2",\n    ))\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=35.0,\n            aperture_A=4.08,\n            depth_A=5.0,\n            max_internal_diameter_A=4.08,\n        ),\n        symmetry="C4v",\n        donor_positions=donors,\n        pocket_scale_nm=0.40,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_ni2_spec() -> InteractionGeometrySpec:\n    """Ni²⁺: strictly 4-coordinate, no axial, M-N ~1.93 Å."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=30.0,\n            aperture_A=3.86,\n            depth_A=3.4,\n            max_internal_diameter_A=3.86,\n        ),\n        symmetry="D4h",\n        donor_positions=_make_4N_donor_positions(1.93),\n        pocket_scale_nm=0.39,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_diagnostic_cu2_spec() -> InteractionGeometrySpec:\n    """Cu²⁺ for diagnostic → should get COOH conjugation handle."""\n    spec = make_cu2_spec()\n    spec.target_application = ApplicationContext.DIAGNOSTIC\n    return spec\n\n\ndef make_pb2_spec() -> InteractionGeometrySpec:\n    """Pb²⁺: very large (0.98 Å), out-of-plane → stress test."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=50.0,\n            aperture_A=4.68,\n            depth_A=4.0,\n            max_internal_diameter_A=4.68,\n        ),\n        symmetry="C4v",\n        donor_positions=_make_4N_donor_positions(2.34),\n        pocket_scale_nm=0.47,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.REMEDIATION,\n        required_scale=ScaleClass.MMOL,\n    )\n\n\n# ─────────────────────────────────────────────\n# Test 1: Knowledge Base\n# ─────────────────────────────────────────────\n\nclass TestKnowledgeBase:\n\n    def test_six_cores(self):\n        assert len(ALL_CORES) == 6\n\n    def test_twelve_metals(self):\n        assert len(METAL_PORPH_DB) >= 12\n\n    def test_seven_substituents(self):\n        assert len(MESO_SUBSTITUENTS) >= 7\n\n    def test_eight_axial_ligands(self):\n        assert len(AXIAL_LIGANDS) >= 8\n\n    def test_tpp_is_D4h(self):\n        assert TPP.cavity_symmetry == "D4h"\n\n    def test_all_cores_have_4_pyrrole_N(self):\n        for core in ALL_CORES.values():\n            assert core.n_pyrrole_N == 4\n\n    def test_core_hole_around_2A(self):\n        for core in ALL_CORES.values():\n            assert 1.8 < core.core_hole_radius_A < 2.2\n\n    def test_pc_smaller_than_tpp(self):\n        """Phthalocyanine has smaller cavity than porphyrin."""\n        assert PC.core_hole_radius_A < TPP.core_hole_radius_A\n\n    def test_backsolve_params(self):\n        assert "N_pyrrole_exchange_kJ_mol" in BACKSOLVE_METAL_PARAMS\n        assert "lfse_scale" in BACKSOLVE_METAL_PARAMS\n\n    def test_cu2_is_labile(self):\n        assert METAL_PORPH_DB["Cu2+"].kinetic_class == "labile"\n\n    def test_fe3_is_inert(self):\n        assert METAL_PORPH_DB["Fe3+"].kinetic_class == "inert"\n\n    def test_ni2_no_axial(self):\n        assert METAL_PORPH_DB["Ni2+"].max_axial_count == 0\n\n    def test_fe3_wants_6_coord(self):\n        assert METAL_PORPH_DB["Fe3+"].preferred_coordination == 6\n\n    def test_pb2_out_of_plane(self):\n        assert not METAL_PORPH_DB["Pb2+"].in_plane\n        assert METAL_PORPH_DB["Pb2+"].displacement_A > 0.5\n\n\n# ─────────────────────────────────────────────\n# Test 2: Size-Match Physics\n# ─────────────────────────────────────────────\n\nclass TestSizeMatch:\n\n    def test_cu2_good_match(self):\n        """Cu²⁺ (0.57 Å) is a classic porphyrin metal."""\n        sm = metal_porphyrin_size_match(0.57, TPP.core_hole_radius_A)\n        assert sm > 0.5\n\n    def test_pb2_poor_match(self):\n        """Pb²⁺ (0.98 Å) is much too large."""\n        sm = metal_porphyrin_size_match(0.98, TPP.core_hole_radius_A)\n        assert sm < 0.3\n\n    def test_core_selection_returns_ranked(self):\n        results = select_core_for_metal("Cu2+")\n        assert len(results) == len(ALL_CORES)\n        scores = [r[1] for r in results]\n        assert scores == sorted(scores, reverse=True)\n\n    def test_core_selection_unknown_metal(self):\n        results = select_core_for_metal("Unobtainium99+")\n        assert results == []\n\n\n# ─────────────────────────────────────────────\n# Test 3: Metalation Prediction\n# ─────────────────────────────────────────────\n\nclass TestMetalationPrediction:\n\n    def test_dG_negative_for_cu2(self):\n        """Cu²⁺ metalation should be favorable (ΔG < 0)."""\n        metal = METAL_PORPH_DB["Cu2+"]\n        dG = predict_metalation_dG(metal, TPP)\n        assert dG < 0\n\n    def test_ewg_raises_dG(self):\n        """Electron-withdrawing meso → less favorable metalation."""\n        metal = METAL_PORPH_DB["Cu2+"]\n        dG_neutral = predict_metalation_dG(metal, TPP, meso_sigma=0.0)\n        dG_ewg = predict_metalation_dG(metal, TPP, meso_sigma=1.0)\n        # Hammett rho is negative → positive sigma makes dG less negative\n        assert dG_ewg > dG_neutral\n\n    def test_axial_stabilizes(self):\n        """Adding axial ligands should make ΔG more negative."""\n        metal = METAL_PORPH_DB["Fe3+"]\n        dG_no_ax = predict_metalation_dG(metal, TPP, n_axial=0)\n        dG_ax = predict_metalation_dG(metal, TPP, n_axial=2)\n        assert dG_ax < dG_no_ax\n\n\n# ─────────────────────────────────────────────\n# Test 4: Adapter estimate_fidelity\n# ─────────────────────────────────────────────\n\nclass TestEstimateFidelity:\n\n    def setup_method(self):\n        self.adapter = PorphyrinAdapter()\n\n    def test_cu2_high_fidelity(self):\n        spec = make_cu2_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert score.physics_fidelity > 0.5\n        assert score.feasible\n\n    def test_fidelity_bounded(self):\n        spec = make_cu2_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert 0.0 <= score.physics_fidelity <= 1.0\n\n    def test_advantages_present(self):\n        spec = make_cu2_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert len(score.advantages) > 0\n\n\n# ─────────────────────────────────────────────\n# Test 5: Full Design Pipeline\n# ─────────────────────────────────────────────\n\nclass TestDesign:\n\n    def setup_method(self):\n        self.adapter = PorphyrinAdapter()\n\n    def test_returns_porphyrin_fab_spec(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert isinstance(fab, PorphyrinFabSpec)\n\n    def test_cu2_gets_porphyrin_core(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert fab.core_type in ("porphyrin", "phthalocyanine")\n\n    def test_cu2_is_4_coordinate(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert fab.metal_coordination == 4\n\n    def test_fe3_gets_axial_ligands(self):\n        """Fe³⁺ prefers 6-coord → should get axial ligands."""\n        spec = make_fe3_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.axial_ligands) >= 1\n\n    def test_zn2_gets_one_axial(self):\n        """Zn²⁺ prefers 5-coord → should get 1 axial."""\n        spec = make_zn2_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.axial_ligands) == 1\n\n    def test_ni2_no_axial(self):\n        """Ni²⁺ is strictly 4-coord → no axial."""\n        spec = make_ni2_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.axial_ligands) == 0\n\n    def test_has_synthesis_steps(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.synthesis_steps) >= 3\n\n    def test_has_metalation_protocol(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.metalation_protocol) > 0\n\n    def test_has_predicted_dG(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert fab.predicted_dG_metalation_kJ_mol < 0\n\n    def test_has_logK(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert fab.predicted_logK_metalation > 0\n\n    def test_has_validation_plan(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.validation_experiments) >= 2\n\n\n# ─────────────────────────────────────────────\n# Test 6: Substituent Selection\n# ─────────────────────────────────────────────\n\nclass TestSubstituents:\n\n    def setup_method(self):\n        self.adapter = PorphyrinAdapter()\n\n    def test_diagnostic_gets_cooh(self):\n        """Diagnostic application → COOH conjugation handle."""\n        spec = make_diagnostic_cu2_spec()\n        fab = self.adapter.design(spec)\n        assert "COOH" in fab.meso_substituent or "4-COOH" in fab.meso_substituent\n\n    def test_ni2_d8_gets_electron_poor(self):\n        """Ni²⁺ (d8) → electron-poor meso (C6F5)."""\n        spec = make_ni2_spec()\n        fab = self.adapter.design(spec)\n        assert fab.meso_substituent in ("C6F5", "Ph")  # C6F5 preferred for d8+\n\n    def test_fe3_defaults_to_standard(self):\n        """Fe³⁺ (d5) → standard phenyl (d5 triggers neither EDG nor EWG path)."""\n        spec = make_fe3_spec()\n        fab = self.adapter.design(spec)\n        # Fe3+ d5 HS: neither d<=4 nor d>=8 → default Ph\n        assert fab.meso_substituent == "Ph"\n\n\n# ─────────────────────────────────────────────\n# Test 7: Edge Cases\n# ─────────────────────────────────────────────\n\nclass TestEdgeCases:\n\n    def setup_method(self):\n        self.adapter = PorphyrinAdapter()\n\n    def test_pb2_out_of_plane(self):\n        """Pb²⁺ is very large — should flag out-of-plane."""\n        spec = make_pb2_spec()\n        fab = self.adapter.design(spec)\n        assert not fab.in_plane\n\n    def test_pb2_validation_warns(self):\n        spec = make_pb2_spec()\n        fab = self.adapter.design(spec)\n        report = self.adapter.validate_design(fab)\n        assert len(report.warnings) > 0\n\n\n# ─────────────────────────────────────────────\n# Test 8: Validation\n# ─────────────────────────────────────────────\n\nclass TestValidation:\n\n    def setup_method(self):\n        self.adapter = PorphyrinAdapter()\n\n    def test_good_design_validates(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        report = self.adapter.validate_design(fab)\n        assert report.valid\n\n    def test_bad_size_match_flags(self):\n        spec = make_cu2_spec()\n        fab = self.adapter.design(spec)\n        fab.size_match_score = 0.1\n        report = self.adapter.validate_design(fab)\n        assert not report.valid\n\n    def test_wrong_type_fails(self):\n        from mabe.realization.models import FabricationSpec, CavityDimensions\n        wrong = FabricationSpec(\n            material_system="not_porph",\n            geometry_spec_hash="x",\n            predicted_pocket_geometry=CavityDimensions(0, 0, 0, 0),\n            predicted_deviation_from_ideal_A=0,\n        )\n        report = self.adapter.validate_design(wrong)\n        assert not report.valid\n\n    def test_too_many_axials_flagged(self):\n        """Ni²⁺ with axial ligands → should flag issue."""\n        spec = make_ni2_spec()\n        fab = self.adapter.design(spec)\n        fab.axial_ligands = ["Im", "Py"]  # Ni2+ max is 0\n        report = self.adapter.validate_design(fab)\n        assert not report.valid\n',
}

def main():
    print("=== MABE Sprint R2c: Porphyrin Adapter ===")
    print()
    for filepath, content in FILES.items():
        dirpath = os.path.dirname(filepath)
        if dirpath:
            os.makedirs(dirpath, exist_ok=True)
        with open(filepath, "w", encoding="utf-8", newline="\n") as f:
            f.write(content)
        print(f"  Created {filepath}")
    print()
    print(f"=== Bootstrap complete: {len(FILES)} files ===")
    print()
    print("Run tests:")
    print("  python -m pytest mabe/realization/tests/test_sprint_r2c.py -v")

if __name__ == "__main__":
    main()