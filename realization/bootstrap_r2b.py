"""
MABE Realization Engine — Sprint R2b Bootstrap (Crown Ether / Cryptand Adapter)
Run from your MABE repo root: python realization\bootstrap_r2b.py

Requires: Sprint R1 already installed (mabe/realization/ exists)
Creates:  3 new files in mabe/realization/adapters/ and tests/
Test:     python -m pytest mabe/realization/tests/test_sprint_r2b.py -v
"""

import os
import sys

if not os.path.isfile("mabe/realization/__init__.py"):
    print("ERROR: Sprint R1 not found. Run bootstrap_realization.py first.")
    sys.exit(1)

FILES = {
    'mabe/realization/adapters/crown_ether_knowledge.py': '"""\nCrown Ether & Cryptand Knowledge Base.\n\nProperties from Izatt critical compilations, Pedersen original data,\nand Buschmann/Schollmeyer thermodynamic reviews.\n\nSize-match selectivity from Hancock & Martell (Chem. Rev. 1989).\nMacrocyclic/cryptate effects from Haymore et al. (Inorg. Chem. 1982).\n\nData sources:\n    - Izatt RM et al. (Chem. Rev. 1985, 1991, 1995) — stability constant compilations\n    - Pedersen CJ (J. Am. Chem. Soc. 1967) — original crown ether work\n    - Buschmann HJ, Schollmeyer E (J. Incl. Phenom. 2000) — thermodynamics\n    - Hancock RD, Martell AE (Chem. Rev. 1989) — chelate ring size selectivity\n    - Lehn JM (Angew. Chem. 1988) — cryptand design principles\n"""\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional\nimport math\n\n\n# ─────────────────────────────────────────────\n# Data types\n# ─────────────────────────────────────────────\n\n@dataclass(frozen=True)\nclass CrownEtherHost:\n    """Physical properties of one crown ether or cryptand."""\n\n    name: str\n    host_class: str                    # "crown_ether", "aza_crown", "thia_crown", "cryptand"\n    common_name: str                   # e.g., "18-crown-6", "[2.2.2]cryptand"\n\n    # ── Ring/cage geometry ──\n    n_donors: int\n    donor_types: list[str]             # ["O","O","O","O","O","O"] for 18-crown-6\n    cavity_radius_A: float             # from crystallography\n    ring_atoms: int                    # total atoms in ring backbone\n    is_3d_cage: bool                   # True for cryptands\n\n    # ── Physicochemical ──\n    mw: float\n    water_soluble: bool\n    organic_soluble: bool\n    smiles: str\n\n    # ── Selectivity data (Izatt compilations) ──\n    best_match_ion: str                # ion with highest log K\n    best_match_ionic_radius_A: float\n    best_match_logK: float             # in water, 25°C\n    selectivity_profile: dict[str, float]  # ion → log K\n\n    # ── Macrocyclic / cryptate effect ──\n    macrocyclic_stabilization_kJ_mol: float\n\n    # ── Production ──\n    commercial: bool\n    cost_per_gram_usd: float\n    common_suppliers: list[str]\n    synthesis_route: str               # "Pedersen", "template", "high-dilution"\n\n    # ── Fields with defaults (must come last) ──\n    cryptate_stabilization_kJ_mol: float = 0.0  # only for cryptands\n    lariat_arm_possible: bool = True\n    n_substitution_possible: bool = False  # N-donor variants\n    benzo_fusion_possible: bool = True\n\n\n@dataclass(frozen=True)\nclass CationTarget:\n    """Target cation properties for size-match calculation."""\n\n    symbol: str\n    charge: int\n    ionic_radius_A: float              # Shannon effective ionic radius (CN=6)\n    ionic_radius_cn4_A: float          # CN=4 where available\n    hsab_class: str                    # "hard", "borderline", "soft"\n    hydration_dG_kJ_mol: float         # Marcus 1991 / Kepp 2019\n    preferred_donors: list[str]        # HSAB-matched donor types\n\n\n# ─────────────────────────────────────────────\n# Cation database (Shannon radii, Marcus hydration)\n# ─────────────────────────────────────────────\n\nCATION_DB: dict[str, CationTarget] = {\n    "Li+": CationTarget("Li+", 1, 0.76, 0.59, "hard", -475.0, ["O", "N"]),\n    "Na+": CationTarget("Na+", 1, 1.02, 0.99, "hard", -365.0, ["O", "N"]),\n    "K+": CationTarget("K+", 1, 1.38, 1.37, "hard", -295.0, ["O"]),\n    "Rb+": CationTarget("Rb+", 1, 1.52, 1.52, "hard", -275.0, ["O"]),\n    "Cs+": CationTarget("Cs+", 1, 1.67, 1.67, "hard", -250.0, ["O"]),\n    "Mg2+": CationTarget("Mg2+", 2, 0.72, 0.57, "hard", -1830.0, ["O", "N"]),\n    "Ca2+": CationTarget("Ca2+", 2, 1.00, 1.00, "hard", -1505.0, ["O"]),\n    "Sr2+": CationTarget("Sr2+", 2, 1.18, 1.18, "hard", -1380.0, ["O"]),\n    "Ba2+": CationTarget("Ba2+", 2, 1.35, 1.35, "hard", -1250.0, ["O"]),\n    "Cu2+": CationTarget("Cu2+", 2, 0.73, 0.57, "borderline", -2010.0, ["N", "S", "O"]),\n    "Zn2+": CationTarget("Zn2+", 2, 0.74, 0.60, "borderline", -1955.0, ["N", "S", "O"]),\n    "Ni2+": CationTarget("Ni2+", 2, 0.69, 0.55, "borderline", -1980.0, ["N", "S"]),\n    "Co2+": CationTarget("Co2+", 2, 0.75, 0.58, "borderline", -1915.0, ["N", "O"]),\n    "Pb2+": CationTarget("Pb2+", 2, 1.19, 0.98, "borderline", -1425.0, ["S", "N", "O"]),\n    "Cd2+": CationTarget("Cd2+", 2, 0.95, 0.78, "soft", -1755.0, ["S", "N"]),\n    "Hg2+": CationTarget("Hg2+", 2, 1.02, 0.96, "soft", -1760.0, ["S"]),\n    "Ag+": CationTarget("Ag+", 1, 1.15, 1.00, "soft", -430.0, ["S", "N"]),\n    "Tl+": CationTarget("Tl+", 1, 1.50, 1.50, "soft", -300.0, ["S", "N"]),\n    "NH4+": CationTarget("NH4+", 1, 1.48, 1.48, "hard", -285.0, ["O"]),\n    "La3+": CationTarget("La3+", 3, 1.03, 1.03, "hard", -3145.0, ["O"]),\n    "Eu3+": CationTarget("Eu3+", 3, 0.95, 0.95, "hard", -3360.0, ["O"]),\n    "UO2_2+": CationTarget("UO2_2+", 2, 0.73, 0.73, "hard", -1600.0, ["O"]),\n}\n\n\n# ─────────────────────────────────────────────\n# Crown ether hosts\n# ─────────────────────────────────────────────\n\nCROWN_12C4 = CrownEtherHost(\n    name="12-crown-4",\n    host_class="crown_ether",\n    common_name="12-crown-4",\n    n_donors=4,\n    donor_types=["O", "O", "O", "O"],\n    cavity_radius_A=0.60,\n    ring_atoms=12,\n    is_3d_cage=False,\n    mw=176.21,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCOCCOCCO1",\n    best_match_ion="Li+",\n    best_match_ionic_radius_A=0.76,\n    best_match_logK=1.7,\n    selectivity_profile={\n        "Li+": 1.7, "Na+": 1.3, "K+": 0.8,\n    },\n    macrocyclic_stabilization_kJ_mol=8.0,\n    commercial=True,\n    cost_per_gram_usd=5.00,\n    common_suppliers=["Sigma-Aldrich", "TCI"],\n    synthesis_route="Pedersen (Williamson ether)",\n)\n\nCROWN_15C5 = CrownEtherHost(\n    name="15-crown-5",\n    host_class="crown_ether",\n    common_name="15-crown-5",\n    n_donors=5,\n    donor_types=["O", "O", "O", "O", "O"],\n    cavity_radius_A=0.86,\n    ring_atoms=15,\n    is_3d_cage=False,\n    mw=220.26,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCOCCOCCOCCO1",\n    best_match_ion="Na+",\n    best_match_ionic_radius_A=1.02,\n    best_match_logK=3.24,\n    selectivity_profile={\n        "Li+": 1.0, "Na+": 3.24, "K+": 2.27, "Rb+": 1.56,\n        "Cs+": 1.17, "Ca2+": 2.30, "Sr2+": 2.80,\n    },\n    macrocyclic_stabilization_kJ_mol=10.0,\n    commercial=True,\n    cost_per_gram_usd=3.00,\n    common_suppliers=["Sigma-Aldrich", "TCI", "Alfa Aesar"],\n    synthesis_route="Pedersen (Williamson ether)",\n)\n\nCROWN_18C6 = CrownEtherHost(\n    name="18-crown-6",\n    host_class="crown_ether",\n    common_name="18-crown-6",\n    n_donors=6,\n    donor_types=["O", "O", "O", "O", "O", "O"],\n    cavity_radius_A=1.34,\n    ring_atoms=18,\n    is_3d_cage=False,\n    mw=264.32,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCOCCOCCOCCOCCO1",\n    best_match_ion="K+",\n    best_match_ionic_radius_A=1.38,\n    best_match_logK=6.10,\n    selectivity_profile={\n        "Li+": 0.8, "Na+": 4.35, "K+": 6.10, "Rb+": 5.35,\n        "Cs+": 4.79, "Ca2+": 3.90, "Sr2+": 5.30, "Ba2+": 5.76,\n        "Pb2+": 4.27, "NH4+": 4.27, "Tl+": 5.87, "Ag+": 4.76,\n    },\n    macrocyclic_stabilization_kJ_mol=12.0,\n    commercial=True,\n    cost_per_gram_usd=1.50,\n    common_suppliers=["Sigma-Aldrich", "TCI", "Alfa Aesar", "Merck"],\n    synthesis_route="Pedersen (Williamson ether)",\n)\n\nCROWN_21C7 = CrownEtherHost(\n    name="21-crown-7",\n    host_class="crown_ether",\n    common_name="21-crown-7",\n    n_donors=7,\n    donor_types=["O", "O", "O", "O", "O", "O", "O"],\n    cavity_radius_A=1.70,\n    ring_atoms=21,\n    is_3d_cage=False,\n    mw=308.37,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCOCCOCCOCCOCCOCCO1",\n    best_match_ion="Cs+",\n    best_match_ionic_radius_A=1.67,\n    best_match_logK=4.50,\n    selectivity_profile={\n        "Na+": 2.10, "K+": 4.30, "Rb+": 4.40,\n        "Cs+": 4.50, "Ba2+": 4.90,\n    },\n    macrocyclic_stabilization_kJ_mol=10.0,\n    commercial=True,\n    cost_per_gram_usd=8.00,\n    common_suppliers=["Sigma-Aldrich", "TCI"],\n    synthesis_route="Pedersen (Williamson ether)",\n)\n\n# ── Aza-crowns (N-donor substitution) ──\n\nDIAZA_18C6 = CrownEtherHost(\n    name="diaza-18-crown-6",\n    host_class="aza_crown",\n    common_name="1,10-diaza-18-crown-6",\n    n_donors=6,\n    donor_types=["O", "O", "N", "O", "O", "N"],\n    cavity_radius_A=1.30,\n    ring_atoms=18,\n    is_3d_cage=False,\n    mw=262.35,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCN(CCOCCOCCN1)CCO",\n    best_match_ion="Cu2+",\n    best_match_ionic_radius_A=0.73,\n    best_match_logK=7.9,\n    selectivity_profile={\n        "Cu2+": 7.9, "Ni2+": 5.4, "Zn2+": 5.1,\n        "Co2+": 3.8, "Pb2+": 6.2, "K+": 3.9,\n    },\n    macrocyclic_stabilization_kJ_mol=15.0,  # N-donors enhance macrocyclic effect\n    commercial=True,\n    cost_per_gram_usd=12.00,\n    common_suppliers=["Sigma-Aldrich", "TCI"],\n    synthesis_route="Richman-Atkins (tosyl route)",\n    n_substitution_possible=True,\n)\n\n# ── Thia-crown (S-donor for soft metals) ──\n\nDITHIA_18C6 = CrownEtherHost(\n    name="dithia-18-crown-6",\n    host_class="thia_crown",\n    common_name="1,10-dithia-18-crown-6",\n    n_donors=6,\n    donor_types=["O", "O", "S", "O", "O", "S"],\n    cavity_radius_A=1.35,\n    ring_atoms=18,\n    is_3d_cage=False,\n    mw=296.43,\n    water_soluble=False,\n    organic_soluble=True,\n    smiles="C1COCCSCCOCCSCCO1",\n    best_match_ion="Ag+",\n    best_match_ionic_radius_A=1.15,\n    best_match_logK=7.2,\n    selectivity_profile={\n        "Ag+": 7.2, "Hg2+": 6.8, "Pb2+": 5.5,\n        "Cu2+": 4.9, "K+": 3.1,\n    },\n    macrocyclic_stabilization_kJ_mol=12.0,\n    commercial=True,\n    cost_per_gram_usd=25.00,\n    common_suppliers=["Sigma-Aldrich", "TCI"],\n    synthesis_route="Pedersen (modified, thiol precursor)",\n)\n\n# ── Cryptands (3D cage) ──\n\nCRYPTAND_211 = CrownEtherHost(\n    name="[2.1.1]cryptand",\n    host_class="cryptand",\n    common_name="[2.1.1]cryptand",\n    n_donors=5,\n    donor_types=["O", "O", "O", "N", "N"],\n    cavity_radius_A=0.80,\n    ring_atoms=17,\n    is_3d_cage=True,\n    mw=247.33,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCN2CCOCCN(CCO1)CC2",\n    best_match_ion="Li+",\n    best_match_ionic_radius_A=0.76,\n    best_match_logK=5.50,\n    selectivity_profile={\n        "Li+": 5.50, "Na+": 3.20, "K+": 1.50,\n    },\n    macrocyclic_stabilization_kJ_mol=10.0,\n    cryptate_stabilization_kJ_mol=12.0,\n    commercial=True,\n    cost_per_gram_usd=50.00,\n    common_suppliers=["Sigma-Aldrich"],\n    synthesis_route="Lehn (high-dilution)",\n)\n\nCRYPTAND_221 = CrownEtherHost(\n    name="[2.2.1]cryptand",\n    host_class="cryptand",\n    common_name="[2.2.1]cryptand",\n    n_donors=6,\n    donor_types=["O", "O", "O", "O", "N", "N"],\n    cavity_radius_A=1.10,\n    ring_atoms=20,\n    is_3d_cage=True,\n    mw=291.39,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCOCCN2CCOCCN(CCO1)CCO2",\n    best_match_ion="Na+",\n    best_match_ionic_radius_A=1.02,\n    best_match_logK=9.70,\n    selectivity_profile={\n        "Li+": 5.40, "Na+": 9.70, "K+": 5.30,\n        "Ca2+": 6.95, "Sr2+": 7.35,\n    },\n    macrocyclic_stabilization_kJ_mol=12.0,\n    cryptate_stabilization_kJ_mol=15.0,\n    commercial=True,\n    cost_per_gram_usd=80.00,\n    common_suppliers=["Sigma-Aldrich"],\n    synthesis_route="Lehn (high-dilution)",\n)\n\nCRYPTAND_222 = CrownEtherHost(\n    name="[2.2.2]cryptand",\n    host_class="cryptand",\n    common_name="[2.2.2]cryptand (Kryptofix 222)",\n    n_donors=8,\n    donor_types=["O", "O", "O", "O", "O", "O", "N", "N"],\n    cavity_radius_A=1.40,\n    ring_atoms=24,\n    is_3d_cage=True,\n    mw=376.50,\n    water_soluble=True,\n    organic_soluble=True,\n    smiles="C1COCCOCCN2CCOCCOCCN(CCOCC1)CCO2",\n    best_match_ion="K+",\n    best_match_ionic_radius_A=1.38,\n    best_match_logK=10.40,\n    selectivity_profile={\n        "Li+": 2.50, "Na+": 7.21, "K+": 10.40, "Rb+": 8.80,\n        "Cs+": 4.40, "Ca2+": 8.10, "Sr2+": 10.80, "Ba2+": 11.60,\n        "Pb2+": 12.40, "Ag+": 9.60, "La3+": 5.80,\n    },\n    macrocyclic_stabilization_kJ_mol=15.0,\n    cryptate_stabilization_kJ_mol=20.0,\n    commercial=True,\n    cost_per_gram_usd=30.00,\n    common_suppliers=["Sigma-Aldrich", "Merck", "TCI"],\n    synthesis_route="Lehn (high-dilution), commercial as Kryptofix 222",\n)\n\n\n# ─────────────────────────────────────────────\n# Indexed registries\n# ─────────────────────────────────────────────\n\nALL_CROWN_HOSTS: dict[str, CrownEtherHost] = {\n    "12-crown-4": CROWN_12C4,\n    "15-crown-5": CROWN_15C5,\n    "18-crown-6": CROWN_18C6,\n    "21-crown-7": CROWN_21C7,\n    "diaza-18-crown-6": DIAZA_18C6,\n    "dithia-18-crown-6": DITHIA_18C6,\n    "[2.1.1]cryptand": CRYPTAND_211,\n    "[2.2.1]cryptand": CRYPTAND_221,\n    "[2.2.2]cryptand": CRYPTAND_222,\n}\n\nCROWNS_ONLY: list[CrownEtherHost] = [\n    CROWN_12C4, CROWN_15C5, CROWN_18C6, CROWN_21C7,\n]\n\nAZA_CROWNS: list[CrownEtherHost] = [DIAZA_18C6]\n\nTHIA_CROWNS: list[CrownEtherHost] = [DITHIA_18C6]\n\nCRYPTANDS: list[CrownEtherHost] = [CRYPTAND_211, CRYPTAND_221, CRYPTAND_222]\n\nALL_HOSTS_LIST: list[CrownEtherHost] = list(ALL_CROWN_HOSTS.values())\n\n\n# ─────────────────────────────────────────────\n# Physics functions\n# ─────────────────────────────────────────────\n\n# Size-match Gaussian parameters\nSIZE_MATCH_SIGMA_A = 0.20  # Å — selectivity width (tighter = more selective)\nSIZE_MATCH_K = 5.0         # kJ/mol — max stabilization at perfect match\n\n\ndef size_match_score(ion_radius_A: float, cavity_radius_A: float) -> float:\n    """\n    Gaussian size-match selectivity.\n\n    Returns 0.0–1.0: 1.0 = perfect r_ion == r_cavity match.\n    From Hancock & Martell cavity size-match model.\n    """\n    return math.exp(\n        -0.5 * ((ion_radius_A - cavity_radius_A) / SIZE_MATCH_SIGMA_A) ** 2\n    )\n\n\ndef size_match_dG(ion_radius_A: float, cavity_radius_A: float) -> float:\n    """\n    Free energy contribution from size-match.\n\n    Returns negative (stabilizing) when well-matched.\n    """\n    return -SIZE_MATCH_K * size_match_score(ion_radius_A, cavity_radius_A)\n\n\ndef hsab_donor_score(ion_hsab: str, donor_types: list[str]) -> float:\n    """\n    HSAB compatibility score for donor set.\n\n    Returns 0.0–1.0: how well the donor types match the ion\'s preference.\n    """\n    preference_map = {\n        "hard": {"O": 1.0, "N": 0.7, "S": 0.2},\n        "borderline": {"O": 0.5, "N": 1.0, "S": 0.7},\n        "soft": {"O": 0.2, "N": 0.5, "S": 1.0},\n    }\n    prefs = preference_map.get(ion_hsab, preference_map["borderline"])\n    if not donor_types:\n        return 0.0\n    scores = [prefs.get(d, 0.3) for d in donor_types]\n    return sum(scores) / len(scores)\n\n\ndef select_best_crown(\n    target_ion: str,\n    require_3d: bool = False,\n    require_water_soluble: bool = True,\n) -> list[tuple[CrownEtherHost, float, float, str]]:\n    """\n    Rank all crown/cryptand hosts for a target cation.\n\n    Returns list of (host, size_match_score, predicted_logK, rationale)\n    sorted by combined score.\n    """\n    if target_ion not in CATION_DB:\n        return []\n\n    cation = CATION_DB[target_ion]\n    results = []\n\n    candidates = ALL_HOSTS_LIST\n    if require_3d:\n        candidates = [h for h in candidates if h.is_3d_cage]\n    if require_water_soluble:\n        candidates = [h for h in candidates if h.water_soluble]\n\n    for host in candidates:\n        sm = size_match_score(cation.ionic_radius_A, host.cavity_radius_A)\n        hsab = hsab_donor_score(cation.hsab_class, host.donor_types)\n\n        # Combined score: size-match dominates, HSAB secondary\n        combined = sm * 0.7 + hsab * 0.3\n\n        # Use known logK if available, else estimate\n        known_logK = host.selectivity_profile.get(target_ion)\n        if known_logK is not None:\n            predicted_logK = known_logK\n        else:\n            # Estimate from size-match + macrocyclic effect\n            base_logK = sm * 6.0  # rough: perfect match ≈ 6 log K\n            macro_bonus = host.macrocyclic_stabilization_kJ_mol / 5.71  # convert to log K\n            crypto_bonus = host.cryptate_stabilization_kJ_mol / 5.71\n            charge_factor = cation.charge * 0.8  # divalent binds stronger\n            predicted_logK = base_logK + macro_bonus + crypto_bonus + (charge_factor - 0.8)\n\n        # Rationale\n        parts = [f"size-match={sm:.2f}"]\n        parts.append(f"HSAB={hsab:.2f}")\n        if known_logK is not None:\n            parts.append(f"known logK={known_logK:.1f}")\n        else:\n            parts.append(f"estimated logK={predicted_logK:.1f}")\n        if host.is_3d_cage:\n            parts.append("3D encapsulation (cryptate effect)")\n        if sm > 0.8:\n            parts.append("excellent size match")\n        elif sm < 0.3:\n            parts.append("poor size match")\n\n        results.append((host, combined, predicted_logK, "; ".join(parts)))\n\n    results.sort(key=lambda x: x[1], reverse=True)\n    return results\n',
    'mabe/realization/adapters/crown_ether_adapter.py': '"""\nCrown Ether / Cryptand Adapter — Layer 4 Implementation.\n\nTakes an InteractionGeometrySpec describing a cation-coordination pocket\nand designs a crown ether or cryptand realization.\n\nDesign logic:\n    1. Identify target cation from spec (donor types + charge + cavity size)\n    2. Rank crown ethers and cryptands by cavity size-match\n    3. HSAB routing for donor atom selection (O/N/S variants)\n    4. Cryptand upgrade when 3D encapsulation improves selectivity\n    5. Produce CrownEtherFabSpec with selection + Izatt-sourced logK\n\nPhysics connection:\n    - Cavity radius → size-match Gaussian (Hancock & Martell)\n    - Macrocyclic stabilization (Haymore et al.)\n    - Cryptate effect (Lehn)\n    - HSAB donor selection (from BackSolve donor subtype calibration)\n"""\n\nfrom __future__ import annotations\n\nimport hashlib\nimport math\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mabe.realization.adapters.base import RealizationAdapter, ValidationReport\nfrom mabe.realization.adapters.crown_ether_knowledge import (\n    ALL_HOSTS_LIST,\n    CATION_DB,\n    CationTarget,\n    CrownEtherHost,\n    CRYPTANDS,\n    hsab_donor_score,\n    select_best_crown,\n    size_match_dG,\n    size_match_score,\n    SIZE_MATCH_SIGMA_A,\n)\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    CavityShape,\n    DeviationReport,\n    FabricationSpec,\n    InteractionGeometrySpec,\n    RealizationScore,\n    Solvent,\n)\nfrom mabe.realization.registry.material_registry import MaterialCapability\n\n\n# ─────────────────────────────────────────────\n# CrownEtherFabSpec — material-specific output\n# ─────────────────────────────────────────────\n\n@dataclass\nclass CrownEtherFabSpec(FabricationSpec):\n    """Fabrication spec for a crown ether or cryptand pocket."""\n\n    # ── Selection ──\n    selected_host: str = ""\n    host_class: str = ""                   # "crown_ether", "aza_crown", etc.\n    cavity_radius_A: float = 0.0\n\n    # ── Target cation ──\n    target_ion: str = ""\n    ion_radius_A: float = 0.0\n\n    # ── Size-match analysis ──\n    size_match_score: float = 0.0\n    size_match_quality: str = ""\n\n    # ── Binding prediction ──\n    predicted_logK: float = 0.0\n    logK_source: str = ""                  # "Izatt_measured" or "estimated"\n    macrocyclic_stabilization_kJ_mol: float = 0.0\n    cryptate_stabilization_kJ_mol: float = 0.0\n    predicted_selectivity_ratio: float = 0.0  # vs best competitor\n\n    # ── HSAB analysis ──\n    hsab_compatibility: float = 0.0\n    donor_types_used: list[str] = field(default_factory=list)\n\n    # ── Design decisions ──\n    cryptand_upgrade: bool = False\n    cryptand_upgrade_rationale: str = ""\n    donor_substitution: str = ""           # "none", "aza", "thia"\n    donor_substitution_rationale: str = ""\n\n    # ── Sourcing ──\n    smiles: str = ""\n    supplier: str = ""\n    catalog_note: str = ""\n\n\n# ─────────────────────────────────────────────\n# Adapter implementation\n# ─────────────────────────────────────────────\n\nclass CrownEtherAdapter(RealizationAdapter):\n    """\n    Designs crown ether / cryptand binding pockets for cation capture.\n\n    Class A (Covalent Cavity) system:\n        - 0.60–1.70 Å cavity radius (12C4 through 21C7)\n        - Circular/spherical coordination geometry\n        - Size-match selectivity is primary mechanism\n        - O-donors default, N/S for borderline/soft cations\n        - Cryptands add 3D encapsulation (+5–20 kJ/mol)\n    """\n\n    def __init__(self, capability: Optional[MaterialCapability] = None):\n        if capability is None:\n            from mabe.realization.registry.material_registry import MATERIAL_REGISTRY\n            capability = MATERIAL_REGISTRY.get("cyclic_encapsulant")\n            if capability is None:\n                capability = _make_crown_capability()\n        super().__init__(capability)\n\n    def estimate_fidelity(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> RealizationScore:\n        """\n        Quick score: can a crown ether or cryptand host this geometry?\n\n        Primary: cavity size → size-match to target ion.\n        Secondary: donor type compatibility (HSAB).\n        """\n\n        target_ion, cation = self._identify_target_cation(spec)\n\n        if cation is None:\n            return self._infeasible_score(\n                "Cannot identify target cation from spec"\n            )\n\n        # ── Rank all hosts ──\n        ranked = select_best_crown(\n            target_ion,\n            require_water_soluble=(spec.solvent == Solvent.AQUEOUS),\n        )\n\n        if not ranked:\n            return self._infeasible_score(\n                f"No host compatible with {target_ion}"\n            )\n\n        best_host, combined_score, predicted_logK, rationale = ranked[0]\n\n        # ── Physics fidelity ──\n        sm = size_match_score(cation.ionic_radius_A, best_host.cavity_radius_A)\n        hsab = hsab_donor_score(cation.hsab_class, best_host.donor_types)\n\n        physics_fidelity = sm * 0.6 + hsab * 0.2\n\n        # Shape: crowns are circular, cryptands are spherical\n        if spec.cavity_shape == CavityShape.SPHERE and best_host.is_3d_cage:\n            physics_fidelity += 0.15\n        elif spec.cavity_shape in (CavityShape.FLAT, CavityShape.SPHERE):\n            physics_fidelity += 0.05\n\n        physics_fidelity = max(0.0, min(1.0, physics_fidelity))\n\n        # ── Deviation ──\n        radius_dev = abs(cation.ionic_radius_A - best_host.cavity_radius_A)\n        deviation = DeviationReport(\n            material_system="crown_ether",\n            element_deviations_A=[radius_dev],\n            max_deviation_A=radius_dev,\n            mean_deviation_A=radius_dev,\n        )\n\n        # ── Advantages / limitations ──\n        advantages = []\n        limitations = []\n\n        if best_host.commercial:\n            advantages.append(\n                f"{best_host.common_name} commercial "\n                f"(${best_host.cost_per_gram_usd}/g)"\n            )\n        if sm > 0.8:\n            advantages.append(f"Excellent size match (score={sm:.2f})")\n        if predicted_logK > 5:\n            advantages.append(f"Strong binding (logK={predicted_logK:.1f})")\n        if best_host.is_3d_cage:\n            advantages.append("Cryptate effect — enhanced selectivity")\n\n        if sm < 0.5:\n            limitations.append(f"Suboptimal size match ({sm:.2f})")\n        if not best_host.water_soluble and spec.solvent == Solvent.AQUEOUS:\n            limitations.append("Not water-soluble")\n        if hsab < 0.5:\n            limitations.append(\n                f"HSAB mismatch: {cation.hsab_class} ion, "\n                f"O-donors suboptimal"\n            )\n\n        return RealizationScore(\n            material_system="crown_ether",\n            adapter_id="CrownEtherAdapter",\n            deviation_from_ideal=deviation,\n            physics_fidelity=physics_fidelity,\n            synthetic_accessibility=0.85,\n            cost_score=0.80,\n            scalability=0.90,\n            operating_condition_compatibility=(\n                0.9 if spec.solvent in (Solvent.AQUEOUS, Solvent.MIXED) else 0.7\n            ),\n            reusability_score=0.5,\n            composite_score=0.0,\n            confidence=0.80,\n            advantages=advantages,\n            limitations=limitations,\n            feasible=True,\n        )\n\n    def design(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> CrownEtherFabSpec:\n        """\n        Full crown ether / cryptand design.\n\n        1. Identify target cation\n        2. Size-match ranking\n        3. HSAB donor selection (aza/thia variants)\n        4. Cryptand upgrade evaluation\n        5. Selectivity estimation\n        """\n\n        spec_hash = hashlib.md5(str(spec).encode()).hexdigest()[:12]\n        target_ion, cation = self._identify_target_cation(spec)\n\n        if cation is None:\n            return self._empty_fab(spec_hash, "Cannot identify target cation")\n\n        # ── Step 1: Size-match ranking ──\n        ranked = select_best_crown(target_ion, require_water_soluble=False)\n        if not ranked:\n            return self._empty_fab(spec_hash, f"No host for {target_ion}")\n\n        best_host, combined, predicted_logK, _rationale = ranked[0]\n        sm = size_match_score(cation.ionic_radius_A, best_host.cavity_radius_A)\n\n        # ── Step 2: HSAB donor substitution ──\n        donor_sub = "none"\n        donor_sub_rationale = ""\n        hsab = hsab_donor_score(cation.hsab_class, best_host.donor_types)\n\n        if cation.hsab_class == "soft" and "S" not in best_host.donor_types:\n            # Look for thia variant — relax radius tolerance since HSAB\n            # benefit can overcome moderate size-match penalty\n            for h in ALL_HOSTS_LIST:\n                if h.host_class == "thia_crown" and abs(\n                    h.cavity_radius_A - cation.ionic_radius_A\n                ) < 0.4:\n                    best_host = h\n                    donor_sub = "thia"\n                    donor_sub_rationale = (\n                        f"Soft cation {target_ion}: S-donors preferred. "\n                        f"Switched to {h.common_name}."\n                    )\n                    break\n\n        elif cation.hsab_class == "borderline" and "N" not in best_host.donor_types:\n            for h in ALL_HOSTS_LIST:\n                if h.host_class == "aza_crown" and abs(\n                    h.cavity_radius_A - cation.ionic_radius_A\n                ) < 0.8:\n                    best_host = h\n                    donor_sub = "aza"\n                    donor_sub_rationale = (\n                        f"Borderline cation {target_ion}: N-donors improve binding. "\n                        f"Switched to {h.common_name}."\n                    )\n                    break\n\n        # ── Step 3: Cryptand upgrade evaluation ──\n        cryptand_upgrade = False\n        cryptand_rationale = ""\n\n        # Consider cryptand if: (a) selectivity needed, or (b) size-match is marginal\n        if spec.must_exclude or sm < 0.7:\n            for h in CRYPTANDS:\n                crypt_sm = size_match_score(\n                    cation.ionic_radius_A, h.cavity_radius_A\n                )\n                if crypt_sm > sm * 0.9:  # cryptand has competitive size-match\n                    crypt_logK = h.selectivity_profile.get(target_ion, 0)\n                    crown_logK = best_host.selectivity_profile.get(target_ion, 0)\n                    if crypt_logK > crown_logK:\n                        best_host = h\n                        sm = crypt_sm\n                        predicted_logK = crypt_logK\n                        cryptand_upgrade = True\n                        cryptand_rationale = (\n                            f"Cryptand [{h.common_name}] provides 3D encapsulation: "\n                            f"logK {crypt_logK:.1f} vs crown {crown_logK:.1f}. "\n                            f"Cryptate stabilization: "\n                            f"{h.cryptate_stabilization_kJ_mol:.0f} kJ/mol."\n                        )\n                        break\n\n        # ── Step 4: Update predicted logK from best host ──\n        known_logK = best_host.selectivity_profile.get(target_ion)\n        logK_source = "Izatt_measured" if known_logK else "estimated"\n        if known_logK:\n            predicted_logK = known_logK\n\n        # ── Step 5: Selectivity estimation ──\n        selectivity_ratio = 1.0\n        if spec.must_exclude:\n            for exc in spec.must_exclude:\n                competitor_logK = best_host.selectivity_profile.get(exc.species, 0)\n                if competitor_logK > 0 and predicted_logK > 0:\n                    ratio = 10 ** (predicted_logK - competitor_logK)\n                    selectivity_ratio = min(selectivity_ratio, ratio)\n\n        # ── Step 6: Size-match quality label ──\n        if sm > 0.9:\n            sm_quality = "excellent"\n        elif sm > 0.7:\n            sm_quality = "good"\n        elif sm > 0.4:\n            sm_quality = "moderate"\n        else:\n            sm_quality = "poor"\n\n        # ── Step 7: Synthesis and sourcing ──\n        steps = []\n        if best_host.commercial:\n            steps.append(f"Procure {best_host.common_name} from {best_host.common_suppliers[0]}")\n        else:\n            steps.append(f"Synthesize {best_host.common_name} via {best_host.synthesis_route}")\n\n        if donor_sub == "thia" and not best_host.commercial:\n            steps.append("Thia-crown synthesis: thiol-alkoxide Williamson condensation")\n        if donor_sub == "aza" and not best_host.commercial:\n            steps.append("Aza-crown synthesis: Richman-Atkins tosyl route")\n\n        validation = [\n            f"ITC: Ka for {target_ion} in target matrix",\n            f"Competitive ITC: selectivity vs major interferents",\n        ]\n        if spec.must_exclude:\n            for exc in spec.must_exclude:\n                validation.append(f"Selectivity assay: {target_ion} vs {exc.species}")\n\n        expected = {\n            "logK": predicted_logK,\n            "Ka_M_inv": 10 ** predicted_logK if predicted_logK < 15 else 1e15,\n            "selectivity_ratio": selectivity_ratio,\n            "binding_stoichiometry": "1:1",\n        }\n\n        return CrownEtherFabSpec(\n            material_system="crown_ether",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(\n                volume_A3=4/3 * math.pi * best_host.cavity_radius_A ** 3,\n                aperture_A=best_host.cavity_radius_A * 2,\n                depth_A=3.0 if not best_host.is_3d_cage else best_host.cavity_radius_A * 2,\n                max_internal_diameter_A=best_host.cavity_radius_A * 2,\n            ),\n            predicted_deviation_from_ideal_A=abs(\n                cation.ionic_radius_A - best_host.cavity_radius_A\n            ),\n            synthesis_steps=steps,\n            estimated_yield=0.70 if best_host.commercial else 0.40,\n            estimated_cost_per_unit=best_host.cost_per_gram_usd,\n            estimated_time="immediate" if best_host.commercial else "3–7 days",\n            validation_experiments=validation,\n            expected_observables=expected,\n            # Crown-specific\n            selected_host=best_host.common_name,\n            host_class=best_host.host_class,\n            cavity_radius_A=best_host.cavity_radius_A,\n            target_ion=target_ion,\n            ion_radius_A=cation.ionic_radius_A,\n            size_match_score=sm,\n            size_match_quality=sm_quality,\n            predicted_logK=predicted_logK,\n            logK_source=logK_source,\n            macrocyclic_stabilization_kJ_mol=best_host.macrocyclic_stabilization_kJ_mol,\n            cryptate_stabilization_kJ_mol=best_host.cryptate_stabilization_kJ_mol,\n            predicted_selectivity_ratio=selectivity_ratio,\n            hsab_compatibility=hsab_donor_score(\n                cation.hsab_class, best_host.donor_types\n            ),\n            donor_types_used=best_host.donor_types,\n            cryptand_upgrade=cryptand_upgrade,\n            cryptand_upgrade_rationale=cryptand_rationale,\n            donor_substitution=donor_sub,\n            donor_substitution_rationale=donor_sub_rationale,\n            smiles=best_host.smiles,\n            supplier=best_host.common_suppliers[0] if best_host.commercial else "custom synthesis",\n            catalog_note=f"{best_host.common_name}, {best_host.mw:.0f} g/mol",\n        )\n\n    def validate_design(self, fab: FabricationSpec) -> ValidationReport:\n        """Check crown/cryptand design for internal consistency."""\n\n        if not isinstance(fab, CrownEtherFabSpec):\n            return ValidationReport(\n                valid=False,\n                issues=["Not a CrownEtherFabSpec"],\n                warnings=[],\n            )\n\n        issues = []\n        warnings = []\n\n        if fab.size_match_score < 0.2:\n            issues.append(\n                f"Size match {fab.size_match_score:.2f} too poor — "\n                "binding will be negligible"\n            )\n\n        if fab.predicted_logK < 1.0:\n            warnings.append(\n                f"Weak binding predicted (logK={fab.predicted_logK:.1f})"\n            )\n\n        if fab.hsab_compatibility < 0.4:\n            warnings.append(\n                f"HSAB mismatch ({fab.hsab_compatibility:.2f}): "\n                "consider aza/thia variant"\n            )\n\n        if fab.predicted_selectivity_ratio < 10 and fab.target_ion:\n            warnings.append(\n                f"Low selectivity ratio ({fab.predicted_selectivity_ratio:.0f}×): "\n                "consider cryptand upgrade"\n            )\n\n        return ValidationReport(\n            valid=len(issues) == 0,\n            issues=issues,\n            warnings=warnings,\n            confidence=0.85 if fab.logK_source == "Izatt_measured" else 0.60,\n        )\n\n    # ─────────────────────────────────────────\n    # Internal\n    # ─────────────────────────────────────────\n\n    def _identify_target_cation(\n        self,\n        spec: InteractionGeometrySpec,\n    ) -> tuple[str, Optional[CationTarget]]:\n        """\n        Identify the target cation from the spec.\n\n        Strategy: match cavity radius to known cation radii.\n        If spec has donor positions with charge info, use that.\n        """\n\n        # Check if any donor has charge annotation suggesting the target\n        for donor in spec.donor_positions:\n            if donor.charge_state < 0:\n                # Anionic donor → cation is the target\n                continue\n\n        # Primary: cavity radius matching\n        # Convert spec cavity diameter to radius\n        spec_radius_A = spec.cavity_dimensions.max_internal_diameter_A / 2.0\n\n        best_match = None\n        best_delta = float("inf")\n\n        for symbol, cation in CATION_DB.items():\n            delta = abs(cation.ionic_radius_A - spec_radius_A)\n            if delta < best_delta:\n                best_delta = delta\n                best_match = (symbol, cation)\n\n        if best_match and best_delta < 1.0:\n            return best_match\n\n        # Fallback: use cavity volume to estimate\n        return "K+", CATION_DB["K+"]  # default to most common crown target\n\n    def _infeasible_score(self, reason: str) -> RealizationScore:\n        return RealizationScore(\n            material_system="crown_ether",\n            adapter_id="CrownEtherAdapter",\n            deviation_from_ideal=DeviationReport(\n                material_system="crown_ether",\n                element_deviations_A=[],\n                max_deviation_A=float("inf"),\n                mean_deviation_A=float("inf"),\n            ),\n            physics_fidelity=0.0,\n            feasible=False,\n            infeasibility_reason=reason,\n        )\n\n    def _empty_fab(self, spec_hash: str, reason: str) -> CrownEtherFabSpec:\n        return CrownEtherFabSpec(\n            material_system="crown_ether",\n            geometry_spec_hash=spec_hash,\n            predicted_pocket_geometry=CavityDimensions(0, 0, 0, 0),\n            predicted_deviation_from_ideal_A=float("inf"),\n            synthesis_steps=[f"DESIGN FAILED: {reason}"],\n        )\n\n\ndef _make_crown_capability() -> MaterialCapability:\n    """Build crown-ether-specific MaterialCapability."""\n    return MaterialCapability(\n        system_id="crown_ether",\n        physics_class="covalent_cavity",\n        adapter_class="CrownEtherAdapter",\n        min_pocket_size_nm=0.12,\n        max_pocket_size_nm=0.34,\n        achievable_symmetries=["Cn", "Cnv", "Dnh"],\n        max_donor_count=8,\n        donor_types_available=["O", "N", "S"],\n        positioning_precision_A=0.05,\n        rigidity_range=("semi-rigid", "rigid"),\n        pH_stability=(2.0, 12.0),\n        thermal_stability_K=(273.0, 500.0),\n        solvent_compatibility=["aqueous", "organic", "mixed"],\n        min_practical_scale="µmol",\n        max_practical_scale="kmol",\n        cost_per_unit_range=(1.50, 80.0),\n        typical_synthesis_time="immediate (commercial) to 7 days",\n        literature_validation_rate=0.85,\n        literature_examples=20000,\n        design_tools_available=["RDKit"],\n        known_strengths=[\n            "Size-match selectivity well-characterized (Izatt)",\n            "Many commercial options",\n            "HSAB-tunable via O/N/S donor substitution",\n            "Cryptand upgrade for enhanced selectivity",\n        ],\n        known_limitations=[\n            "Primarily cation-selective",\n            "Organic crown ethers can be toxic",\n            "Conformational flexibility in larger rings",\n        ],\n    )\n',
    'mabe/realization/tests/test_sprint_r2b.py': '"""\nSprint R2b Test Suite — Crown Ether / Cryptand Adapter.\n\nTests:\n    - Knowledge base integrity (hosts, cations, size-match data)\n    - Size-match selection (K+ → 18C6, Li+ → 12C4, Na+ → 15C5)\n    - HSAB donor routing (soft → thia, borderline → aza)\n    - Cryptand upgrade logic\n    - Full design pipeline (spec → CrownEtherFabSpec)\n    - Validation checks\n"""\n\nimport math\nimport pytest\n\nfrom mabe.realization.adapters.crown_ether_adapter import (\n    CrownEtherAdapter,\n    CrownEtherFabSpec,\n)\nfrom mabe.realization.adapters.crown_ether_knowledge import (\n    ALL_CROWN_HOSTS,\n    ALL_HOSTS_LIST,\n    CATION_DB,\n    CROWN_12C4,\n    CROWN_15C5,\n    CROWN_18C6,\n    CROWN_21C7,\n    CRYPTAND_222,\n    CRYPTANDS,\n    DIAZA_18C6,\n    DITHIA_18C6,\n    hsab_donor_score,\n    select_best_crown,\n    size_match_score,\n)\nfrom mabe.realization.models import (\n    ApplicationContext,\n    CavityDimensions,\n    CavityShape,\n    DonorPosition,\n    ExclusionSpec,\n    InteractionGeometrySpec,\n    ScaleClass,\n    Solvent,\n)\n\n\n# ─────────────────────────────────────────────\n# Spec fixtures — cation-sized pockets\n# ─────────────────────────────────────────────\n\ndef make_potassium_spec() -> InteractionGeometrySpec:\n    """K+ pocket: r_ion=1.38 Å → diameter=2.76 Å → 18-crown-6 (r_cav=1.34)."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=11.0,\n            aperture_A=2.76,\n            depth_A=3.0,\n            max_internal_diameter_A=2.76,\n        ),\n        symmetry="C6v",\n        donor_positions=[\n            DonorPosition(\n                atom_type="O",\n                coordination_role="lone_pair_donor",\n                position_vector_A=(1.34, 0.0, 0.0),\n                tolerance_A=0.1,\n                required_hybridization="sp3",\n                charge_state=-0.3,\n            ),\n        ],\n        pocket_scale_nm=0.28,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.SEPARATION,\n        required_scale=ScaleClass.MMOL,\n    )\n\n\ndef make_lithium_spec() -> InteractionGeometrySpec:\n    """Li+ pocket: r_ion=0.76 Å → diameter=1.52 Å → 12-crown-4 (r_cav=0.60)."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=1.8,\n            aperture_A=1.52,\n            depth_A=2.5,\n            max_internal_diameter_A=1.52,\n        ),\n        symmetry="C4v",\n        donor_positions=[],\n        pocket_scale_nm=0.15,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_sodium_spec() -> InteractionGeometrySpec:\n    """Na+ pocket: r_ion=1.02 Å → diameter=2.04 Å → 15-crown-5 (r_cav=0.86)."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=4.4,\n            aperture_A=2.04,\n            depth_A=3.0,\n            max_internal_diameter_A=2.04,\n        ),\n        symmetry="C5v",\n        donor_positions=[],\n        pocket_scale_nm=0.20,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_cesium_spec() -> InteractionGeometrySpec:\n    """Cs+ pocket: r_ion=1.67 Å → diameter=3.34 Å → 21-crown-7 (r_cav=1.70)."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=19.5,\n            aperture_A=3.34,\n            depth_A=3.0,\n            max_internal_diameter_A=3.34,\n        ),\n        symmetry="C7v",\n        donor_positions=[],\n        pocket_scale_nm=0.34,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.REMEDIATION,\n        required_scale=ScaleClass.MOL,\n    )\n\n\ndef make_silver_spec() -> InteractionGeometrySpec:\n    """Ag+ (soft): r_ion=1.15 Å → should trigger thia-crown."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=6.4,\n            aperture_A=2.30,\n            depth_A=3.0,\n            max_internal_diameter_A=2.30,\n        ),\n        symmetry="none",\n        donor_positions=[],\n        pocket_scale_nm=0.23,\n        solvent=Solvent.MIXED,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_copper_spec() -> InteractionGeometrySpec:\n    """Cu2+ (borderline): r_ion=0.73 Å → should trigger aza-crown."""\n    return InteractionGeometrySpec(\n        cavity_shape=CavityShape.FLAT,\n        cavity_dimensions=CavityDimensions(\n            volume_A3=1.6,\n            aperture_A=1.46,\n            depth_A=3.0,\n            max_internal_diameter_A=1.46,\n        ),\n        symmetry="none",\n        donor_positions=[],\n        pocket_scale_nm=0.15,\n        solvent=Solvent.AQUEOUS,\n        target_application=ApplicationContext.RESEARCH,\n        required_scale=ScaleClass.UMOL,\n    )\n\n\ndef make_potassium_with_exclusion_spec() -> InteractionGeometrySpec:\n    """K+ pocket with Na+ exclusion → should consider cryptand upgrade."""\n    spec = make_potassium_spec()\n    spec.must_exclude = [\n        ExclusionSpec(species="Na+", max_allowed_affinity_kJ_mol=-10.0, exclusion_mechanism="size"),\n    ]\n    return spec\n\n\n# ─────────────────────────────────────────────\n# Test 1: Knowledge Base\n# ─────────────────────────────────────────────\n\nclass TestKnowledgeBase:\n\n    def test_nine_hosts_total(self):\n        assert len(ALL_CROWN_HOSTS) == 9\n\n    def test_four_basic_crowns(self):\n        for name in ["12-crown-4", "15-crown-5", "18-crown-6", "21-crown-7"]:\n            assert name in ALL_CROWN_HOSTS\n\n    def test_three_cryptands(self):\n        assert len(CRYPTANDS) == 3\n\n    def test_cavity_radii_increase_with_ring_size(self):\n        assert (CROWN_12C4.cavity_radius_A\n                < CROWN_15C5.cavity_radius_A\n                < CROWN_18C6.cavity_radius_A\n                < CROWN_21C7.cavity_radius_A)\n\n    def test_cation_database(self):\n        assert len(CATION_DB) >= 15\n        assert "K+" in CATION_DB\n        assert "Li+" in CATION_DB\n        assert "Na+" in CATION_DB\n\n    def test_cation_hsab_classes(self):\n        assert CATION_DB["K+"].hsab_class == "hard"\n        assert CATION_DB["Cu2+"].hsab_class == "borderline"\n        assert CATION_DB["Ag+"].hsab_class == "soft"\n\n    def test_all_hosts_commercial(self):\n        for h in ALL_HOSTS_LIST:\n            assert h.commercial\n\n    def test_18c6_best_match_is_potassium(self):\n        assert CROWN_18C6.best_match_ion == "K+"\n\n    def test_cryptand_222_is_3d(self):\n        assert CRYPTAND_222.is_3d_cage\n\n    def test_cryptand_has_cryptate_stabilization(self):\n        assert CRYPTAND_222.cryptate_stabilization_kJ_mol > 0\n\n\n# ─────────────────────────────────────────────\n# Test 2: Size-Match Physics\n# ─────────────────────────────────────────────\n\nclass TestSizeMatch:\n\n    def test_perfect_match_score_1(self):\n        """Identical radii → score = 1.0."""\n        assert size_match_score(1.38, 1.38) == pytest.approx(1.0)\n\n    def test_large_mismatch_near_zero(self):\n        """Very different radii → score ≈ 0."""\n        assert size_match_score(0.60, 1.70) < 0.01\n\n    def test_score_symmetric(self):\n        """Score doesn\'t depend on which is larger."""\n        assert (size_match_score(1.0, 1.2)\n                == pytest.approx(size_match_score(1.2, 1.0)))\n\n    def test_k_matches_18c6(self):\n        """K+ (1.38 Å) vs 18C6 (1.34 Å) → excellent match."""\n        sm = size_match_score(1.38, 1.34)\n        assert sm > 0.9\n\n    def test_li_matches_12c4(self):\n        """Li+ (0.76 Å) vs 12C4 (0.60 Å) → reasonable match."""\n        sm = size_match_score(0.76, 0.60)\n        assert sm > 0.3\n\n    def test_na_matches_15c5(self):\n        """Na+ (1.02 Å) vs 15C5 (0.86 Å) → good match."""\n        sm = size_match_score(1.02, 0.86)\n        assert sm > 0.3\n\n    def test_k_in_12c4_poor(self):\n        """K+ (1.38 Å) in 12C4 (0.60 Å) → terrible match."""\n        sm = size_match_score(1.38, 0.60)\n        assert sm < 0.05\n\n\n# ─────────────────────────────────────────────\n# Test 3: HSAB Donor Scoring\n# ─────────────────────────────────────────────\n\nclass TestHSAB:\n\n    def test_hard_prefers_oxygen(self):\n        score_O = hsab_donor_score("hard", ["O", "O", "O"])\n        score_S = hsab_donor_score("hard", ["S", "S", "S"])\n        assert score_O > score_S\n\n    def test_soft_prefers_sulfur(self):\n        score_S = hsab_donor_score("soft", ["S", "S", "S"])\n        score_O = hsab_donor_score("soft", ["O", "O", "O"])\n        assert score_S > score_O\n\n    def test_borderline_prefers_nitrogen(self):\n        score_N = hsab_donor_score("borderline", ["N", "N", "N"])\n        score_O = hsab_donor_score("borderline", ["O", "O", "O"])\n        assert score_N > score_O\n\n\n# ─────────────────────────────────────────────\n# Test 4: Crown Selection\n# ─────────────────────────────────────────────\n\nclass TestCrownSelection:\n\n    def test_k_selects_18c6_family(self):\n        """K+ → 18-crown-6 or [2.2.2]cryptand (both r ≈ 1.34-1.40)."""\n        results = select_best_crown("K+")\n        best = results[0][0]\n        assert best.cavity_radius_A > 1.2\n\n    def test_li_selects_small_cavity(self):\n        """Li+ → small cavity (12C4 or [2.1.1]cryptand)."""\n        results = select_best_crown("Li+")\n        best = results[0][0]\n        assert best.cavity_radius_A < 1.0\n\n    def test_na_selects_medium_cavity(self):\n        """Na+ → medium cavity."""\n        results = select_best_crown("Na+")\n        best = results[0][0]\n        assert 0.7 < best.cavity_radius_A < 1.4\n\n    def test_cs_selects_large_cavity(self):\n        """Cs+ → large cavity (21C7 region)."""\n        results = select_best_crown("Cs+")\n        best = results[0][0]\n        assert best.cavity_radius_A > 1.3\n\n    def test_results_sorted_by_score(self):\n        results = select_best_crown("K+")\n        scores = [r[1] for r in results]\n        assert scores == sorted(scores, reverse=True)\n\n    def test_unknown_ion_returns_empty(self):\n        results = select_best_crown("Unobtainium3+")\n        assert results == []\n\n\n# ─────────────────────────────────────────────\n# Test 5: Adapter estimate_fidelity\n# ─────────────────────────────────────────────\n\nclass TestEstimateFidelity:\n\n    def setup_method(self):\n        self.adapter = CrownEtherAdapter()\n\n    def test_potassium_high_fidelity(self):\n        spec = make_potassium_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert score.physics_fidelity > 0.4\n        assert score.feasible\n\n    def test_lithium_feasible(self):\n        spec = make_lithium_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert score.feasible\n\n    def test_fidelity_bounded(self):\n        spec = make_potassium_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert 0.0 <= score.physics_fidelity <= 1.0\n\n    def test_advantages_populated(self):\n        spec = make_potassium_spec()\n        score = self.adapter.estimate_fidelity(spec)\n        assert len(score.advantages) > 0\n\n\n# ─────────────────────────────────────────────\n# Test 6: Full Design Pipeline\n# ─────────────────────────────────────────────\n\nclass TestDesign:\n\n    def setup_method(self):\n        self.adapter = CrownEtherAdapter()\n\n    def test_returns_crown_fab_spec(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert isinstance(fab, CrownEtherFabSpec)\n\n    def test_potassium_gets_18c6_family(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert fab.cavity_radius_A > 1.2\n\n    def test_lithium_gets_small_host(self):\n        spec = make_lithium_spec()\n        fab = self.adapter.design(spec)\n        assert fab.cavity_radius_A < 1.0\n\n    def test_sodium_gets_medium_host(self):\n        spec = make_sodium_spec()\n        fab = self.adapter.design(spec)\n        assert 0.7 < fab.cavity_radius_A < 1.4\n\n    def test_has_predicted_logK(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert fab.predicted_logK > 0\n\n    def test_has_synthesis_steps(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.synthesis_steps) > 0\n\n    def test_has_validation_plan(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.validation_experiments) >= 1\n        assert any("ITC" in v for v in fab.validation_experiments)\n\n    def test_has_smiles(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert len(fab.smiles) > 0\n\n    def test_size_match_score_present(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert 0.0 < fab.size_match_score <= 1.0\n\n\n# ─────────────────────────────────────────────\n# Test 7: HSAB Donor Routing\n# ─────────────────────────────────────────────\n\nclass TestDonorRouting:\n\n    def setup_method(self):\n        self.adapter = CrownEtherAdapter()\n\n    def test_silver_gets_thia(self):\n        """Ag+ (soft) → thia-crown with S-donors."""\n        spec = make_silver_spec()\n        fab = self.adapter.design(spec)\n        assert fab.donor_substitution == "thia" or "S" in fab.donor_types_used\n\n    def test_copper_gets_aza(self):\n        """Cu2+ (borderline) → aza-crown with N-donors."""\n        spec = make_copper_spec()\n        fab = self.adapter.design(spec)\n        assert fab.donor_substitution == "aza" or "N" in fab.donor_types_used\n\n    def test_potassium_stays_oxygen(self):\n        """K+ (hard) → standard O-donor crown, no substitution."""\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        assert fab.donor_substitution in ("none", "")\n\n\n# ─────────────────────────────────────────────\n# Test 8: Cryptand Upgrade\n# ─────────────────────────────────────────────\n\nclass TestCryptandUpgrade:\n\n    def setup_method(self):\n        self.adapter = CrownEtherAdapter()\n\n    def test_exclusion_triggers_cryptand_consideration(self):\n        """K+ with Na+ exclusion → should at least consider cryptand."""\n        spec = make_potassium_with_exclusion_spec()\n        fab = self.adapter.design(spec)\n        # Either upgrades to cryptand or explains why not\n        assert isinstance(fab, CrownEtherFabSpec)\n\n    def test_cryptand_has_higher_logK_for_k(self):\n        """[2.2.2]cryptand logK for K+ > 18-crown-6 logK."""\n        k_logK_222 = CRYPTAND_222.selectivity_profile.get("K+", 0)\n        k_logK_18c6 = CROWN_18C6.selectivity_profile.get("K+", 0)\n        assert k_logK_222 > k_logK_18c6\n\n\n# ─────────────────────────────────────────────\n# Test 9: Validation\n# ─────────────────────────────────────────────\n\nclass TestValidation:\n\n    def setup_method(self):\n        self.adapter = CrownEtherAdapter()\n\n    def test_good_design_validates(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        report = self.adapter.validate_design(fab)\n        assert report.valid\n\n    def test_poor_size_match_flagged(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        fab.size_match_score = 0.1\n        report = self.adapter.validate_design(fab)\n        assert not report.valid\n\n    def test_wrong_type_fails(self):\n        from mabe.realization.models import FabricationSpec, CavityDimensions\n        wrong = FabricationSpec(\n            material_system="not_crown",\n            geometry_spec_hash="x",\n            predicted_pocket_geometry=CavityDimensions(0, 0, 0, 0),\n            predicted_deviation_from_ideal_A=0,\n        )\n        report = self.adapter.validate_design(wrong)\n        assert not report.valid\n\n    def test_measured_logK_higher_confidence(self):\n        spec = make_potassium_spec()\n        fab = self.adapter.design(spec)\n        report = self.adapter.validate_design(fab)\n        if fab.logK_source == "Izatt_measured":\n            assert report.confidence > 0.8\n',
}

def main():
    print("=== MABE Sprint R2b: Crown Ether / Cryptand Adapter ===")
    print()
    for filepath, content in FILES.items():
        dirpath = os.path.dirname(filepath)
        if dirpath:
            os.makedirs(dirpath, exist_ok=True)
        with open(filepath, "w", encoding="utf-8", newline="\n") as f:
            f.write(content)
        print(f"  Created {filepath}")
    print()
    print(f"=== Bootstrap complete: {len(FILES)} files ===")
    print()
    print("Run tests:")
    print("  python -m pytest mabe/realization/tests/test_sprint_r2b.py -v")

if __name__ == "__main__":
    main()