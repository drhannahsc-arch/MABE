"""
core/candidate.py - What MABE returns: candidate solutions with honest uncertainty.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional


@dataclass
class PerformancePrediction:
    """Probabilistic assessment. Never a single number."""
    probability_of_success: float
    confidence: str
    confidence_reasoning: str
    sensitive_to: list[str] = field(default_factory=list)
    failure_modes: list[str] = field(default_factory=list)
    what_improves_odds: list[str] = field(default_factory=list)
    selectivity_threats: list[str] = field(default_factory=list)


@dataclass
class EvidenceProfile:
    """What is known vs predicted. MABE never hides this distinction."""
    source_type: str
    literature_references: list[str] = field(default_factory=list)
    computational_method: str = ""
    what_would_validate: str = ""
    notes: str = ""


@dataclass
class AccessibilityProfile:
    """Values-aligned assessment. Public good first."""
    estimated_cost: str
    equipment_required: list[str] = field(default_factory=list)
    community_lab_feasible: bool = False
    reusability_cycles: Optional[int] = None
    waste_generated: str = ""
    end_of_life: str = ""


@dataclass
class ImmobilizationOption:
    """How this candidate attaches to a physical substrate. Nothing released to environment."""
    substrate: str
    attachment_chemistry: str
    click_handle: str
    effect_on_binding: str
    notes: str = ""


@dataclass
class ApplicationConnection:
    """A cross-domain application this design could address."""
    domain: str
    description: str
    what_would_change: str
    confidence: str


@dataclass
class CandidateResult:
    """One possible solution to the user's problem."""
    rank: int
    name: str
    description: str
    modality: str
    source_tool: str
    structure_description: str
    performance: PerformancePrediction
    evidence: EvidenceProfile
    accessibility: AccessibilityProfile
    immobilization_options: list[ImmobilizationOption] = field(default_factory=list)
    other_applications: list[ApplicationConnection] = field(default_factory=list)

    def short_summary(self) -> str:
        conf = self.performance.confidence
        prob = f"{self.performance.probability_of_success:.0%}"
        cost = self.accessibility.estimated_cost
        return (
            f"#{self.rank}: {self.name} ({self.modality})\n"
            f"   Success probability: {prob} ({conf}) | Cost: {cost} | "
            f"Evidence: {self.evidence.source_type}"
        )

    def full_report(self) -> str:
        lines = [
            f"{'=' * 60}",
            f"  #{self.rank}: {self.name}",
            f"{'=' * 60}",
            f"",
            f"  {self.description}",
            f"",
            f"  Modality: {self.modality}",
            f"  Structure: {self.structure_description}",
            f"  Generated by: {self.source_tool}",
            f"",
            f"-- Performance --",
            f"  Probability of success: {self.performance.probability_of_success:.0%}",
            f"  Confidence: {self.performance.confidence}",
            f"  Reasoning: {self.performance.confidence_reasoning}",
        ]

        if self.performance.failure_modes:
            lines.append(f"")
            lines.append(f"  What could go wrong:")
            for fm in self.performance.failure_modes:
                lines.append(f"    - {fm}")

        if self.performance.what_improves_odds:
            lines.append(f"")
            lines.append(f"  What improves your odds:")
            for imp in self.performance.what_improves_odds:
                lines.append(f"    - {imp}")

        if self.performance.selectivity_threats:
            lines.append(f"")
            lines.append(f"  Selectivity threats:")
            for st in self.performance.selectivity_threats:
                lines.append(f"    - {st}")

        lines.extend([
            f"",
            f"-- Evidence --",
            f"  Type: {self.evidence.source_type}",
        ])
        if self.evidence.literature_references:
            lines.append(f"  Literature:")
            for ref in self.evidence.literature_references:
                lines.append(f"    - {ref}")
        if self.evidence.computational_method:
            lines.append(f"  Method: {self.evidence.computational_method}")
        if self.evidence.what_would_validate:
            lines.append(f"  To validate: {self.evidence.what_would_validate}")

        lines.extend([
            f"",
            f"-- Accessibility --",
            f"  Cost: {self.accessibility.estimated_cost}",
            f"  Equipment: {', '.join(self.accessibility.equipment_required) or 'basic lab'}",
            f"  Community lab feasible: {'Yes' if self.accessibility.community_lab_feasible else 'No'}",
        ])
        if self.accessibility.reusability_cycles:
            lines.append(f"  Reusability: ~{self.accessibility.reusability_cycles} cycles")
        if self.accessibility.waste_generated:
            lines.append(f"  Waste: {self.accessibility.waste_generated}")
        if self.accessibility.end_of_life:
            lines.append(f"  End of life: {self.accessibility.end_of_life}")

        if self.immobilization_options:
            lines.append(f"")
            lines.append(f"-- Immobilization Options --")
            for opt in self.immobilization_options:
                lines.append(f"  - {opt.substrate} via {opt.attachment_chemistry}")
                lines.append(f"    Handle: {opt.click_handle}")
                lines.append(f"    Effect on binding: {opt.effect_on_binding}")

        if self.other_applications:
            lines.append(f"")
            lines.append(f"-- What Else Could This Do --")
            for app in self.other_applications:
                lines.append(f"  - [{app.confidence}] {app.domain}: {app.description}")
                lines.append(f"    Would need: {app.what_would_change}")

        return "\n".join(lines)
