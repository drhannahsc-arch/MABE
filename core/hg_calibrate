"""
hg_calibrate.py — Phase 6 calibration: fit hydrophobic transfer parameters.

Fits γ_flat, k_curvature, and portal correction terms against the
host-guest dataset (hg_dataset.py).

Strategy:
  1. Pre-compute all guest SASA values (expensive, do once)
  2. Bounded least-squares on 7 HG_PARAMS
  3. Report R², MAE, and per-host-family performance
"""

import numpy as np
from scipy.optimize import least_squares

from hg_dataset import HG_DATA, HOST_DB
from hg_scorer import (
    HG_PARAMS, compute_guest_sasa, estimate_buried_sasa,
    predict_hg_log_ka, evaluate_dataset, LN10_RT,
)
from hg_hbond import HBOND_PARAMS
from hg_pi import PI_PARAMS
from hg_conf_shape import CONF_SHAPE_PARAMS


# ═══════════════════════════════════════════════════════════════════════════
# PARAMETER SPECIFICATION
# ═══════════════════════════════════════════════════════════════════════════
# (name, dict_name, key, initial, lower, upper)

HG_PARAM_SPEC = [
    # Phase 6: hydrophobic transfer
    ("gamma_flat",       "HG", "gamma_flat",       0.025,  0.010,  0.045),
    ("k_curvature",      "HG", "k_curvature",      1.15,   1.00,   2.50),
    ("dg_dehydr_per_A2", "HG", "dg_dehydr_per_A2",-0.070, -0.150,  0.0),
    ("dehydr_CB",        "HG", "dehydr_CB",         3.67,   0.5,    6.0),
    ("dehydr_CD",        "HG", "dehydr_CD",         0.64,   0.0,    2.0),
    ("dehydr_other",     "HG", "dehydr_other",      1.74,   0.0,    3.0),
    # Phase 6: portal corrections RETIRED — replaced by Phase 7 H-bond module
    # epsilon_hbond, epsilon_cation, k_electrostatic now handled by hg_hbond.py
    ("k_size_penalty",   "HG", "k_size_penalty",    0.031,  0.0,    5.0),
    ("k_undersize",      "HG", "k_undersize",       0.0,    0.0,    0.15),
    # Phase 7: H-bond network
    ("eps_neutral",      "HB", "eps_neutral",       -3.0, -12.0,    0.0),
    ("eps_charge_asst",  "HB", "eps_charge_assisted",-10.0,-25.0,   -2.0),
    ("eps_oh_pi",        "HB", "eps_oh_pi",         -1.5,  -6.0,    0.0),
    ("water_penalty",    "HB", "water_penalty_per_hb", 3.5, 0.0,   12.0),
    ("water_displace",   "HB", "water_displacement",  1.2,  0.5,    3.0),
    # Phase 8: π-interactions
    ("eps_ch_pi",        "PI", "eps_ch_pi",         -1.5,  -5.0,    0.0),
    ("eps_pi_stack",     "PI", "eps_pi_stack",      -4.0, -12.0,    0.0),
    ("eps_cation_pi",    "PI", "eps_cation_pi",     -5.0, -15.0,    0.0),
    # Phase 9: conformational entropy
    ("eps_rotor",        "CS", "eps_rotor",          2.5,   0.5,    6.0),
    ("f_partial",        "CS", "f_partial",          0.5,   0.1,    0.9),
    # Phase 10: shape complementarity
    ("k_shape",          "CS", "k_shape",           -8.0, -20.0,    0.0),
    ("PC_optimal",       "CS", "PC_optimal",         0.55,  0.35,   0.70),
    ("sigma_PC",         "CS", "sigma_PC",           0.15,  0.05,   0.35),
]

N_HG_PARAMS = len(HG_PARAM_SPEC)


def apply_hg_params(x):
    """Patch HG_PARAMS, HBOND_PARAMS, PI_PARAMS, and CONF_SHAPE_PARAMS."""
    for i, (_, dict_name, key, *_) in enumerate(HG_PARAM_SPEC):
        if dict_name == "HG":
            HG_PARAMS[key] = x[i]
        elif dict_name == "HB":
            HBOND_PARAMS[key] = x[i]
        elif dict_name == "PI":
            PI_PARAMS[key] = x[i]
        elif dict_name == "CS":
            CONF_SHAPE_PARAMS[key] = x[i]


def get_hg_x0():
    return [p[3] for p in HG_PARAM_SPEC]


def get_hg_bounds():
    lo = [p[4] for p in HG_PARAM_SPEC]
    hi = [p[5] for p in HG_PARAM_SPEC]
    return lo, hi


def residuals(x):
    """Residual vector for least-squares."""
    apply_hg_params(x)
    res = []
    for e in HG_DATA:
        try:
            pred = predict_hg_log_ka(e)
        except Exception:
            pred = 0.0
        res.append(pred - e["log_Ka"])
    return res


# ═══════════════════════════════════════════════════════════════════════════
# MAIN CALIBRATION
# ═══════════════════════════════════════════════════════════════════════════

def calibrate():
    print("═" * 65)
    print("  MABE Phase 6: Host-Guest Hydrophobic Calibration")
    print("═" * 65)
    print(f"  Dataset:    {len(HG_DATA)} host-guest pairs")
    print(f"  Parameters: {N_HG_PARAMS}")
    print(f"  Ratio:      {len(HG_DATA)/N_HG_PARAMS:.1f}:1")

    # Pre-warm SASA cache
    print("\n── Pre-computing guest SASA ──")
    for e in HG_DATA:
        try:
            compute_guest_sasa(e["guest_smiles"])
        except Exception as ex:
            print(f"  ⚠ SASA failed for {e['name']}: {ex}")

    # Before calibration
    x0 = get_hg_x0()
    apply_hg_params(x0)
    print("\n── BEFORE calibration ──")
    stats = evaluate_dataset(HG_DATA)
    print(f"  R²   = {stats['r2']:.4f}")
    print(f"  MAE  = {stats['mae']:.2f} log Ka")
    print(f"  RMSE = {stats['rmse']:.2f} log Ka")
    print(f"  Max  = {abs(stats['max_err']):.1f} ({stats['worst']})")

    # Phase 1: bounded least-squares
    print("\n── Fitting (bounded least-squares) ──")
    lo, hi = get_hg_bounds()
    result = least_squares(
        residuals, x0,
        bounds=(lo, hi),
        method="trf",
        max_nfev=5000,
    )
    print(f"  Converged: {result.success}")
    print(f"  Evaluations: {result.nfev}")

    # Apply best params
    apply_hg_params(result.x)

    # After calibration
    print("\n── AFTER calibration ──")
    stats = evaluate_dataset(HG_DATA)
    print(f"  R²   = {stats['r2']:.4f}")
    print(f"  MAE  = {stats['mae']:.2f} log Ka")
    print(f"  RMSE = {stats['rmse']:.2f} log Ka")
    print(f"  Max  = {abs(stats['max_err']):.1f} ({stats['worst']})")

    # Per-host performance
    print("\n── Per-host family ──")
    from collections import defaultdict
    host_errors = defaultdict(list)
    for e in HG_DATA:
        try:
            pred = predict_hg_log_ka(e)
        except Exception:
            pred = 0.0
        host_errors[e["host"]].append(pred - e["log_Ka"])

    print(f"  {'Host':15s} {'N':>3s} {'MAE':>6s} {'RMSE':>6s} {'Bias':>6s}")
    for host in sorted(host_errors):
        errs = np.array(host_errors[host])
        mae = np.mean(np.abs(errs))
        rmse = np.sqrt(np.mean(errs**2))
        bias = np.mean(errs)
        print(f"  {host:15s} {len(errs):3d} {mae:6.2f} {rmse:6.2f} {bias:+6.2f}")

    # Print fitted parameters
    print("\n── Fitted parameters ──")
    print(f"  {'Name':20s} {'Value':>8s} {'Low':>8s} {'High':>8s} {'AtBound':>8s}")
    print("  " + "─" * 55)
    for i, (name, dict_name, key, init, lb, ub) in enumerate(HG_PARAM_SPEC):
        val = result.x[i]
        at = ""
        if abs(val - lb) < 1e-6:
            at = "→LOW"
        elif abs(val - ub) < 1e-6:
            at = "→HIGH"
        print(f"  {name:20s} {val:8.4f} {lb:8.4f} {ub:8.4f} {at:>8s}")

    # Physical interpretation — find by name
    param_vals = {HG_PARAM_SPEC[i][0]: result.x[i] for i in range(len(HG_PARAM_SPEC))}
    gamma_flat = param_vals["gamma_flat"]
    k_curv = param_vals["k_curvature"]
    dg_deh = param_vals["dg_dehydr_per_A2"]
    deh_CB = param_vals["dehydr_CB"]
    deh_CD = param_vals["dehydr_CD"]
    gamma_eff_concave = gamma_flat * k_curv
    eps_n = param_vals["eps_neutral"]
    eps_ca = param_vals["eps_charge_asst"]
    w_pen = param_vals["water_penalty"]
    w_disp = param_vals["water_displace"]
    print(f"\n── Physical interpretation ──")
    print(f"  γ_flat:                {gamma_flat:.4f} kJ/(mol·Å²)")
    print(f"  γ_concave:             {gamma_eff_concave:.4f} kJ/(mol·Å²)")
    print(f"  Literature γ range:    0.018–0.030 kJ/(mol·Å²)")
    print(f"  Dehydr. base:          {dg_deh:.4f} kJ/(mol·Å²)")
    print(f"  Total γ_eff (CB):      {gamma_eff_concave + abs(dg_deh)*deh_CB:.4f}")
    print(f"  Total γ_eff (CD):      {gamma_eff_concave + abs(dg_deh)*deh_CD:.4f}")
    in_range = 0.015 <= gamma_flat <= 0.045
    print(f"  γ_flat {'✓ within' if in_range else '⚠ outside'} expected bounds")
    print(f"\n  H-bond terms:")
    print(f"  ε_neutral:             {eps_n:.2f} kJ/mol (lit: -2 to -5)")
    print(f"  ε_charge_assisted:     {eps_ca:.2f} kJ/mol (lit: -8 to -15)")
    if eps_n != 0:
        print(f"  ratio CA/neutral:      {eps_ca/eps_n:.1f}× (lit: 3-5×)")
    net_neutral = eps_n + w_pen * w_disp
    net_ca = eps_ca + w_pen * w_disp
    print(f"  Net per neutral HB:    {net_neutral:.2f} kJ/mol (after water penalty)")
    print(f"  Net per CA HB:         {net_ca:.2f} kJ/mol (after water penalty)")

    # π-interaction interpretation
    eps_chpi = param_vals.get("eps_ch_pi", 0)
    eps_pipi = param_vals.get("eps_pi_stack", 0)
    eps_catpi = param_vals.get("eps_cation_pi", 0)
    print(f"\n  π-interaction terms:")
    print(f"  ε_CH-π:                {eps_chpi:.2f} kJ/mol (lit: -1 to -3)")
    print(f"  ε_π-stack:             {eps_pipi:.2f} kJ/mol (lit: -2 to -8)")
    print(f"  ε_cation-π:            {eps_catpi:.2f} kJ/mol (lit: -2 to -10)")

    # Conf entropy + shape
    eps_rot = param_vals.get("eps_rotor", 0)
    f_part = param_vals.get("f_partial", 0)
    k_shp = param_vals.get("k_shape", 0)
    pc_opt = param_vals.get("PC_optimal", 0)
    sig_pc = param_vals.get("sigma_PC", 0)
    print(f"\n  Conformational entropy:")
    print(f"  ε_rotor:               {eps_rot:.2f} kJ/mol (lit: 1.5–4.5)")
    print(f"  f_partial:             {f_part:.2f} (lit: 0.3–0.7)")
    print(f"  Cost per frozen rotor: {eps_rot * f_part:.2f} kJ/mol")
    print(f"\n  Shape complementarity:")
    print(f"  k_shape:               {k_shp:.2f} kJ/mol (lit: -5 to -15)")
    print(f"  PC_optimal:            {pc_opt:.2f} (Rebek rule: 0.55)")
    print(f"  σ_PC:                  {sig_pc:.2f}")

    # Export
    print(f"\n# ═══════════════════════════════════════════")
    print(f"# FITTED PARAMS — paste into modules")
    print(f"# ═══════════════════════════════════════════")
    print(f"HG_PARAMS = {{")
    for i, (name, dn, key, *_) in enumerate(HG_PARAM_SPEC):
        if dn == "HG":
            print(f'    "{key}": {result.x[i]:.4f},')
    print(f"}}\n")
    print(f"HBOND_PARAMS = {{")
    for i, (name, dn, key, *_) in enumerate(HG_PARAM_SPEC):
        if dn == "HB":
            print(f'    "{key}": {result.x[i]:.4f},')
    print(f"}}\n")
    print(f"PI_PARAMS = {{")
    for i, (name, dn, key, *_) in enumerate(HG_PARAM_SPEC):
        if dn == "PI":
            print(f'    "{key}": {result.x[i]:.4f},')
    print(f"}}\n")
    print(f"CONF_SHAPE_PARAMS = {{")
    for i, (name, dn, key, *_) in enumerate(HG_PARAM_SPEC):
        if dn == "CS":
            print(f'    "{key}": {result.x[i]:.4f},')
    print(f"}}")

    return result.x


if __name__ == "__main__":
    calibrate()